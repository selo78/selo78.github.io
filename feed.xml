<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SELO&#39;s Autobiography</title>
  <subtitle>SELO&#39;s LOG</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://selo77.github.io/"/>
  <updated>2017-03-04T09:40:45.000Z</updated>
  <id>https://selo77.github.io/</id>
  
  <author>
    <name>SELO77</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>INTRODUCTION TO ALGORITHMS STUDY 공지</title>
    <link href="https://selo77.github.io/2017/03/04/INRODUCTION-TO-ALGORITHMS-0/"/>
    <id>https://selo77.github.io/2017/03/04/INRODUCTION-TO-ALGORITHMS-0/</id>
    <published>2017-03-04T07:02:34.000Z</published>
    <updated>2017-03-04T09:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>(아래 내용은 업데이트시 변경될 수 있습니다.)</p>
<p>안녕하세요. 개발자 새로입니다. 이번에 힘든 알고리즘 스터디를 진행하려 합니다. 시작부터 힘든 스터디라 칭하는 이유는 여러가지가 있습니다. 첫번째는 스터디 주제가 알고리즘 입니다. 두번째는 알고리즘을 제대로 공부하는 스터디 입니다. 세번째는 알고리즘을 이해하는 스터디입니다. (물론 힘듦의 기준은 개인의 역량에 따라 달라질 수 있습니다. 제 기준으로 매우 힘든 스터디…)</p>
<p>위와 같은 목표를 달성하기 위해 <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/" target="_blank" rel="external">MIT ALGORITHMS COURSE</a>에서 사용하는 <a href="http://www.yes24.com/24/goods/13776831?scode=032&amp;OzSrank=1" target="_blank" rel="external">INTRODUCTION TO ALGORITHMS 3rd</a> 교재와 함께 스터디를 진행합니다. 번역판 있습니다.</p>
<img src="/2017/03/04/INRODUCTION-TO-ALGORITHMS-0/Clrs3.jpeg" alt="INTRODUCTION TO ALGORITHMS 3rd" title="INTRODUCTION TO ALGORITHMS 3rd">
<h2 id="스터디-정보"><a href="#스터디-정보" class="headerlink" title="스터디 정보"></a>스터디 정보</h2><h3 id="스터디-모집대상"><a href="#스터디-모집대상" class="headerlink" title="스터디 모집대상"></a>스터디 모집대상</h3><p>알고리즘에 대한 열망, 부족함을 알고 극복하려는 개발자</p>
<h3 id="스터디-진행방식"><a href="#스터디-진행방식" class="headerlink" title="스터디 진행방식"></a>스터디 진행방식</h3><p>스터디는 매주 한번 평일 2시간 정도 만나서 진행 되며, 장소는 제가 근무중인 <a href="https://team.mymusictaste.com/" target="_blank" rel="external">마이뮤직테이스트</a>(강남구청근처)나 불가능할 시에는 강남인근 스터디 룸에서 진행 될 예정입니다.</p>
<p>진행할 교재 내용과 과제를 감안한 스터디 플랜입니다.</p>
<ul>
<li>소주제(Ex. 1.1알고리즘) 1~2개 단위의 학습 범위를 일주일전에 함께 정하고 개인적으로 학습한다. (목차는 포스팅 하단 참고)</li>
<li>소주제 마다 포함된 연습문제가 있고, 연습문제를 본인이 생각하기에 충분한 노력을 들여서 풀어온다. 문제를 풀면서 공유하고 싶은 주제를 한개 이상 구체적인 질문으로 만들어온다. (책을 보신분은 아시겠지만 연습문제가 결코 쉽지 않습니다.)</li>
<li>각자의 과제를 공유하고, 궁금한 점을 토론한다.</li>
<li>마지막으로 <a href="https://www.chegg.com/homework-help/introduction-to-algorithms-3rd-edition-chapter-1.1-solutions-9780262033848" target="_blank" rel="external">모범답안</a>을 확인 후 토론한다.</li>
</ul>
<p>개인적으로 생각한 스터디 플랜은 위와 같지만 더 좋은 방식이 있을시 변경될 수 있습니다.</p>
<p>위 교재는 크게 총 8장으로 나누어지는데 이번 스터디에서는 3장 자료구조까지 진행됩니다. 3장까지의 분량(약 400페이지)도 결코 만만치 않습니다… 물론 이번 스터디가 마무리 된후에 뒷 단원 내용도 따로 스터디를 진행할 예정입니다.</p>
<p>마지막으로 하나더. 이번 스터디는 어느정도의 강제성과 의무감을 위해 강력한(?) Deposit(10만원!!!) 제도가 존재합니다. Deposit은 스터디 회칙에 어긋나는 행동을 했을때 차감되며, 스터디 완료시 돌려받게됩니다. Deposit에서 차감된 금액은 스터디원의 먹거리 비용으로 처리됩니다.</p>
<h3 id="스터디-지원-제출-폼"><a href="#스터디-지원-제출-폼" class="headerlink" title="스터디 지원 제출 폼"></a>스터디 지원 제출 폼</h3><p>Click <a href="https://docs.google.com/forms/d/e/1FAIpQLSc8fj5BI9YZIjpqrOx87YxtG_O8v8T6HbP0Gz35fU7W9qnRjg/viewform?usp=sf_link" target="_blank" rel="external">Apply  Form</a></p>
<h3 id="스터디-회칙"><a href="#스터디-회칙" class="headerlink" title="스터디 회칙"></a>스터디 회칙</h3><p>현재 스터디 회칙은 다음과 같습니다.</p>
<ul>
<li>두번째 참석까지는 deposit을 내지 않는다. 두번째 참석 후 지속 참여 여부 결정과 deposit 납입</li>
<li>결석 만원 차감</li>
<li>지각 오천원 차감</li>
<li>과제 불 이행시 만원 차감</li>
<li>Deposit 탕진시 스터디 탈퇴 혹은 Deposit 충전</li>
<li>차감된 금액은 스터디원의 먹거리 구입으로 사용됨</li>
<li>스터디 완료 전까지 deposit 반환 불가</li>
</ul>
<blockquote>
<p>I 기초<br>개요<br>1장. 알고리즘의 역할<br>1.1 알고리즘<br>1.2 기술로서의 알고리즘<br>2장. 시작하기<br>2.1 삽입 정렬<br>2.2 알고리즘의 분석<br>2.3 알고리즘의 설계<br>3장. 함수의 증가<br>3.1 점근적 표기<br>3.2 표준 표기법과 흔히 사용되는 함수<br>4장. 분할정복<br>4.1 최대 부분배열 문제<br>4.2 행렬 곱셈을 위한 스트라센 알고리즘<br>4.3 점화식을 풀기 위한 치환법<br>4.4 점화식을 풀기 위한 재귀 트리 방법<br>4.5 점화식을 풀기 위한 마스터방법<br>4.6 마스터 정리의 증명<br>5장. 확률적 분석과 랜덤화된 알고리즘<br>5.1 고용 문제<br>5.2 지표 확률 변수<br>5.3 랜덤화된 알고리즘<br>5.4 확률적 분석과 지표 확률 변수의 기타 활용</p>
<p>II 정렬과 순서 통계량<br>개요<br>6장. 힙 정렬<br>6.1 힙<br>6.2 힙 특성 유지하기<br>6.3 힙 만들기<br>6.4 힙 정렬 알고리즘<br>6.5 우선순위 큐<br>7장. 퀵 정렬<br>7.1 퀵 정렬<br>7.2 퀵 정렬의 성능<br>7.3 랜덤화된 퀵 정렬<br>7.4 퀵 정렬 분석<br>8장. 선형 시간 정렬<br>8.1 정렬의 하한<br>8.2 계수 정렬<br>8.3 기수 정렬<br>8.4 버킷 정렬<br>9장. 중앙값과 순서 통계량<br>9.1 최솟값과 최댓값<br>9.2 선형적인 평균 수행시간에 선택하기<br>9.3 최악의 경우선형 시간에 선택하기</p>
<p>III 자료구조<br>개요<br>10장. 기본 자료구조<br>10.1 스택과 큐<br>10.2 연결 리스트<br>10.3 포인터와 객체 구현하기<br>10.4 루트 있는 트리 표현하기<br>11장. 해시 테이블<br>11.1 직접 주소 테이블<br>11.2 해시 테이블<br>11.3 해시 함수<br>11.4 개방 주소화 방법<br>11.5 완전 해싱<br>12장. 이진 검색 트리<br>12.1 이진 검색 트리의 개념<br>12.2 이진 검색 트리에 대한 질의<br>12.3 삽입과 삭제<br>12.4 임의로 만들어진 이진 검색 트리<br>13장. 레드블랙 트리<br>13.1 레드블랙 트리의 특성<br>13.2 회전<br>13.3 삽입<br>13.4 삭제<br>14장. 자료구조의 확장<br>14.1 동적 순서 통계량<br>14.2 자료구조 확장 기법<br>14.3 구간 트리(349~)</p>
</blockquote>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을 수 있습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/08/11/datastructure-basic/" title="자료구조 알고리즘은 꼭 필요한 것인가?">자료구조 알고리즘은 꼭 필요한 것인가?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(아래 내용은 업데이트시 변경될 수 있습니다.)&lt;/p&gt;
&lt;p&gt;안녕하세요. 개발자 새로입니다. 이번에 힘든 알고리즘 스터디를 진행하려 합니다. 시작부터 힘든 스터디라 칭하는 이유는 여러가지가 있습니다. 첫번째는 스터디 주제가 알고리즘 입니다. 두번
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://selo77.github.io/tags/Algorithm/"/>
    
      <category term="Datastructure" scheme="https://selo77.github.io/tags/Datastructure/"/>
    
  </entry>
  
  <entry>
    <title>Python data model</title>
    <link href="https://selo77.github.io/2016/12/21/Python-data-model/"/>
    <id>https://selo77.github.io/2016/12/21/Python-data-model/</id>
    <published>2016-12-21T13:04:31.000Z</published>
    <updated>2016-12-21T15:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h2><p>하나의 언어를 완벽히 이해한다는 것은 다른 언어를 배울때 제반지식으로 도움이됩니다. 프로그래밍 언어를 사용하는 수준이 아닌 이해하는 수준은 확연히 다릅니다. 파이썬을 사용하고 코드를 작성하는데 어느정도 익숙해 젔다면, 우리는 이제 이해를 하기 위해 노력해야합니다. 파이썬 개발자라면 더욱 그러합니다.</p>
<p>그렇다면 파이썬을 이해하기 위해서는 부분부터 접근해야 할까요? 저는 data model로부터 시작하려 합니다.</p>
<h2 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h2><p>파이썬은 기본적으로 <strong>OOP</strong> 를 지원합니다. Javascript 혹은 Java에서 어떤 컬렉션(예를 들면 Array)의 길이를 구할때 <code>customersArray.length</code> 와 같은 코드를 작성합니다. <code>customerArray</code> 있는 속성중 내부적으로 계산된 <code>length</code> 속성에 접근해 값을 얻습니다. 하지만 파이썬에서는 어떠한가요? <code>len(customerArray)</code> 와 같은 방식으로 길이를 얻습니다. OOP의 관점에서 이것은 옳은 방식일까요? 같이 천천히 답을 찾아봅시다.</p>
<p>파이썬에서 모든것은 객체입니다. 객체의 종류는 크게 두가지로 나누어집니다. <strong>내장 자료형 객체</strong> 와 <strong>사용자 정의 객체</strong> 입니다. 우리가 일반적으로 쓰는 파이썬(C파이썬)에서 <code>len(customerArray)</code>는 인터프리터에 의해 어떻게 해석되고 실행될까요? 답은 두 가지 입니다. <code>customerArray</code>가 내장 자료형이라면 <code>PyVarObject</code> C 구조체의 <code>ob_size</code> 필드의 값을 리턴 합니다. 반면 사용자 정의 객체일 경우 <code>customerArray.__len__()</code>를 실행합니다.</p>
<p>보기에는 분명 같은 코드로 보이지만 왜 이런 차이를 갖게 되는 걸까요?</p>
<p><code>list</code>, <code>dict</code>, <code>tuple</code>, <code>set</code>과 같은 내장 자료형의 항목 수를 가져오는 연산 작업은 매우 빈번하게 일어납니다. 이러한 작업들은 매우 효율적으로 작동해야 합니다. 그래서 파이썬은 단지 내장 자료 객체 자료형에 관해서는 단지 C의 구조체 필드를 읽습니다.</p>
<p>사용자 정의 객체에 <code>__len__()</code> 매직 메소드가 구현되어 있다고 가정할때, 우리는 <code>len(customerArray)</code>라는 일관성을 갖는 코드로 항목수를 구하는 동일한 문제를 해결할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; customerList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">int</span> size = customerList.size();</span><br><span class="line"></span><br><span class="line">String[] array = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> size = array.length;</span><br></pre></td></tr></table></figure></p>
<p>위는 자바 코드에서 <code>ArrayList</code> 와 <code>String Array</code> 의 항목수를 구하는 코드입니다.</p>
<blockquote>
<p><strong>어떠한 케이스도 규칙을 무너트릴 만큼 충분하지 않다</strong> - zen of python</p>
</blockquote>
<p>그렇습니다. 파이썬에 <strong>어떠한 케이스도 규칙을 무너트릴 만큼 충분하지 않다</strong> 고 말합니다. 이러한 철학 덕분에 <strong>일관성</strong> 이라는 장점을 갖게되었습니다.</p>
<h2 id="Foot"><a href="#Foot" class="headerlink" title="Foot"></a>Foot</h2><p>파이썬에서 객체는 크게 내장객체와 사용자 정의 객체로 나누어집니다. 파이썬에서는 <code>__len__()</code>, <code>__getitem__()</code>, <code>__iter__()</code>, <code>__repr__()</code> 등과 같은 매직 메소드를 API로 제공합니다. 결국 우리는 API를 사용해 구현하면 될 뿐이고, 파이썬의 일관성 철학 덕분에 사용자 정의 객체도 내장 객체와 동일한 연산자?로 호출할수 있습니다. 결국, 파이썬 데이터 모델은 프레임워크와 같이 시퀀스, 반복자, 함수, 클래스 등 언어 자체의 구성단위에 대한 Interface를 공식적으로 정의합니다.</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>단순히 어떤 기술의 사용법을 설명하는 것보다 기술에 대한 이해에 관해 글쓰는 것은 정말 어려운것 같습니다.ㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠㅠ</p>
<p>이러한 개념을 처음 접하는 분이라면 가볍게 읽고 넘기길 추천합니다. 이러한 추상적인 개념들을 한번에 이해한다면 그 사람은 다른 세계의 존재일 것이고, 저와 같은 평범한 분들은 머리에 인덱스 정도 새긴다 생각하세요. 조금 더 깊게 살펴보고 싶으신분은 <a href="https://docs.python.org/2/reference/datamodel.html" target="_blank" rel="external">https://docs.python.org/2/reference/datamodel.html</a> 를 읽어 보세요. 저는 읽다 포기했습니다…</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=8781382" target="_blank" rel="external">Book: Fluent 파이썬</a></li>
<li><a href="https://docs.python.org/2/reference/datamodel.html" target="_blank" rel="external">https://docs.python.org/2/reference/datamodel.html</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을 수 있습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Head&quot;&gt;&lt;a href=&quot;#Head&quot; class=&quot;headerlink&quot; title=&quot;Head&quot;&gt;&lt;/a&gt;Head&lt;/h2&gt;&lt;p&gt;하나의 언어를 완벽히 이해한다는 것은 다른 언어를 배울때 제반지식으로 도움이됩니다. 프로그래밍 언어를 사용하는 
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="Python" scheme="https://selo77.github.io/tags/Python/"/>
    
      <category term="Python data model" scheme="https://selo77.github.io/tags/Python-data-model/"/>
    
      <category term="magic method" scheme="https://selo77.github.io/tags/magic-method/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency in Python</title>
    <link href="https://selo77.github.io/2016/12/11/Concurrency-in-Python/"/>
    <id>https://selo77.github.io/2016/12/11/Concurrency-in-Python/</id>
    <published>2016-12-10T15:14:24.000Z</published>
    <updated>2016-12-21T14:14:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>안녕하세요. SELO 입니다. 저희 회사에서는 격주 단위로 개발세미나를 진행하는데요. 개발자가 자유롭게 주제를 선택하여 세미나를 진행한답니다. 최근에 개인적으로 관심을 두고 있던 Concurrency에 관하여 세미나를 진행하게 되었고, 그 내용을 정리해보려 합니다.</p>
<p>전반적인 내용은 다음과 같습니다. Concurrency의 개념을 정리하고, Python에서의 Concurrency 구현에 대하여 살펴보겠습니다.</p>
<h2 id="Concurrency-and-Parallelism"><a href="#Concurrency-and-Parallelism" class="headerlink" title="Concurrency and Parallelism"></a>Concurrency and Parallelism</h2><p>동시성은 무엇이고, 병렬성은 무엇일까요? 잠시 생각해보고, 스스로 답변해보세요. 명확하게 정리가 되신다면 이 파트는 뛰어넘으셔도 됩니다. 그렇지 않으시다면 저와 같이 정리를 한번 해봅시다.</p>
<blockquote>
<p>컴퓨터 과학에서 동시성이란 프로그램, 알고리즘 또는 문제가 분리될수 있는 속성을 말합니다. 즉, 프로그램 또는 알고리즘들이 무작위나 부분적 순서를 갖고 실행 되더라도 동일한 최종결과를 얻습니다.<br><a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science" target="_blank" rel="external"> Concurrency (Computer Science) - wikipedia</a>)</p>
</blockquote>
<p>위키피디아에 정의된 동시성 정의는 위와 같습니다. 개념자체가 추상적이기 때문에 한 번에 이해하기가 조금 어렵습니다. 조금 더 구체적으로 정의하자면 동시에 두 개 이상의 작업을 다루는 구조를 동시성이라 합니다. 그렇다면 병렬성은 무엇일까요? 우리가 알고 있는 병렬성도 분명히 두개 이상의 작업이 함께 다루어지는 것 아닌가요?</p>
<blockquote>
<p>컴퓨터 과학에서 병렬처리란 많은 계산이나 프로세스 실행이 동시에 수행되는 일종의 실행 방식입니다.<br><a href="https://en.wikipedia.org/wiki/Parallel_computing" target="_blank" rel="external">Parallel computing - wikipedia</a></p>
</blockquote>
<p>한마디로 병렬성은 두 개 이상의 연산이 동시에 처리되는 실행 방식입니다. 동시성 보다는 개념이 더 뚜렷해보이지 않나요? 그 이유는 차차 알게되겠지만 <strong>병렬성은 일종의 실행방식에 대한 개념이고, 동시성은 구조에 관한 개념이기 때문에 훨씬 더 추상적입니다. 그리고 비동기, 병렬처리 등과 같은 동시성 구현을 위한 처리나 실행 방식의 개념을 포괄합니다.</strong></p>
<p>아래 그림은 동시성과 병렬성의 이해를 위한 극단적인 예시입니다. 하지만 혼동되는 개념을 정리하는데 도움이 됩니다. 그림을 보아도 혼동이 된다면 아래 정리만 기억해주세요.</p>
<img src="/2016/12/11/Concurrency-in-Python/Concurrency_vs_Parallelism.png" alt="Concurrency Vs Parallelism" title="Concurrency Vs Parallelism">
<p><strong>동시성은 동시에 많은 것을 다루는 구조</strong><br><strong>병렬성은 동시에 많은 것을 실행하는 처리방식</strong></p>
<h2 id="Implement-Concurrency-in-Python"><a href="#Implement-Concurrency-in-Python" class="headerlink" title="Implement Concurrency in Python"></a>Implement Concurrency in Python</h2><p>이번 부분에서는 파이썬에서 동시성 구현해보고, 각 방법의 차이를 이해하는 시간을 갖겠습니다.</p>
<h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>동시성 구현에서 개발자에게 가장 익숙한 것은 스레드가 아닐까 생각됩니다. 스레드는 기본적으로 독립적인 실행 흐름을 갖고, 프로그램의 메모리를 공유합니다. 스레드의 개념을 짚고 넘어가는 이유는 차후 얘기하게 될 파이썬에서의 스레드가 갖게 되는 제약을 명확히 이해하기 위해서입니다.</p>
<ul>
<li><strong>cpu/0basic.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpu/0basic.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_work</span><span class="params">(start, end, result)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        sum += i</span><br><span class="line">    result[<span class="string">'sum'</span>] = sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    START, END = <span class="number">0</span>, <span class="number">100000000</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    st = time.time()</span><br><span class="line">    do_work(START, END, result)</span><br><span class="line">    print(<span class="string">'== sum:&#123;&#125; running time &#123;:.4f&#125;s'</span>.format(result[<span class="string">'sum'</span>],time.time() - st))</span><br><span class="line">    <span class="comment"># == sum:4999999950000000 running time 8.6880s</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>위 코드는 단순히 0 부터 100000000(일만)까지 순차적으로 더한 후 실행시간을 출력하는 프로그램입니다. 동시성이 구현되지 않은 절차식 코드입니다. 제 컴퓨터 기준 8.6s의 실행시간이 출력되었습니다.</p>
<p>반면 아래 코드는 파이썬 <code>threading</code> 모듈을 사용해서 두개의 스레드를 생성한 후 더하기 작업을 반씩 나누어 처리하는 코드입니다. 예측되는 실행시간은 절차식 코드의 실행시간의 절반인 4~5초 언저리가 될것입니다.</p>
<ul>
<li><strong>cpu/1thread.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpu/1thread.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_work</span><span class="params">(start, end, result)</span>:</span></span><br><span class="line">    <span class="comment"># print(os.getpid())</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end):</span><br><span class="line">        sum += i</span><br><span class="line">    result.append(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    START, END = <span class="number">0</span>, <span class="number">100000000</span></span><br><span class="line">    result = list()</span><br><span class="line">    st = time.time()</span><br><span class="line">    th1 = Thread(target=do_work, args=(START, int(END/<span class="number">2</span>), result))</span><br><span class="line">    th2 = Thread(target=do_work, args=(int(END/<span class="number">2</span>), END, result))</span><br><span class="line">    th1.start()</span><br><span class="line">    th2.start()</span><br><span class="line">    th1.join()</span><br><span class="line">    th2.join()</span><br><span class="line">    print(<span class="string">'==sum:&#123;&#125;, running time &#123;:.4f&#125;s'</span>.format(sum(result),time.time() - st))</span><br><span class="line">    <span class="comment"># ==sum:4999999950000000, running time 8.9179s</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>실행 결과는 우리가 예상했던 바와는 너무도 다릅니다. 출력된 실행시간을 보면 8.9s로 스레드를 구현하지 않은 코드보다 조금 더 느립니다. 스레드가 정상적으로 작동하였다면 이런 결과는 나올수가 없겠죠.<br>이유는 바로 GIL(Global Interpreter Lock) 이라는 놈때문 입니다.</p>
<blockquote>
<p>Global interpreter lock (GIL) is a mechanism used in computer language interpreters to synchronize the execution of threads so that only one native thread can execute at a time.<br><a href="https://en.wikipedia.org/wiki/Global_interpreter_lock" target="_blank" rel="external">Global interpreter lock - Wikipedia</a></p>
</blockquote>
<p>GIL에 대해서 다루는 포스팅은 아니기에 짧게 설명하고 넘어가도록하겠습니다. GIL은 한번에 한 스레드만 파이썬 바이트 코드를 실행하도록 강제합니다. 그렇기 때문에 단일 파이썬 프로세스가 동시에 다중 CPU 코어를 사용할 수 없습니다. 그렇다면 제대로 쓰지도 못하는 스레드 모듈을 왜 만들었을까요?</p>
<p>GIL에 대한 자세한 내용은 아래 문서를 참고하세요.<br><a href="http://www.dabeaz.com/python/UnderstandingGIL.pdf" target="_blank" rel="external">UnderstandingGIL</a></p>
<ul>
<li><strong>io/0basic.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># io/0basic.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'http://www.naver.com'</span>,</span><br><span class="line">       <span class="string">'https://www.google.com'</span>,</span><br><span class="line">       <span class="string">'https://www.apple.com'</span>,</span><br><span class="line">       <span class="string">'http://www.bing.com/'</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'Start with'</span>, url)</span><br><span class="line">    urlopen(url)</span><br><span class="line">    print(<span class="string">'End'</span>, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st = time.time()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    fetch(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"duration(s):&#123;:.4f&#125;"</span>.format(time.time() - st))</span><br><span class="line"><span class="comment"># duration(s):6.0583</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>이번 코드에서는 40개의 url에 해당하는 http network 작업을 절차적으로 실행합니다. 대략 6.0s 실행시간이 걸렸습니다. 아래코드는 같은 문제를 4개의 thread를 생성 작업하는 방식입니다.</p>
<ul>
<li><strong>io/1thread.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'http://www.naver.com'</span>,</span><br><span class="line">       <span class="string">'https://www.google.com'</span>,</span><br><span class="line">       <span class="string">'https://www.apple.com'</span>,</span><br><span class="line">       <span class="string">'http://www.bing.com/'</span>] * <span class="number">10</span></span><br><span class="line">NUM_WORKERS = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'Start with'</span>, url)</span><br><span class="line">    urlopen(url)</span><br><span class="line">    print(<span class="string">'End'</span>, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=NUM_WORKERS) <span class="keyword">as</span> th:</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        th.submit(fetch, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"duration(s):&#123;:.4f&#125;, NUM_WORKERS:&#123;&#125;"</span>.format((time.time() - st), NUM_WORKERS))</span><br><span class="line"><span class="comment"># duration(s):1.6696, NUM_WORKERS:4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>첫번째 <code>cpu/1thread.py</code>는 스레드가 정삭적을 작동하는것 같아 보이지 않습니다. 스레드를 사용했음에도 불구하고 절차코드보다 느린 실행시간이 걸렸습니다. 그렇다면 이번 <code>io/1thread.py</code> 코드도 스레드가 정상적으로 작동하지 않았을까요? 아닙니다. 출력된 내용을 보면 1.6s의 실행시간이 걸렸습니다. 절차형 코드 6.0s 비해 1/4 실행시간이 걸렸습니다. 왜 이런 차이가 생기는 걸까요?</p>
<p>코드가 해결하려하는 핵심 작업의 종류가 다르기 때문입니다. 첫번째 스레드 코드는 CPU-Bound 작업이 중심이였고, 두번째 스레드 코드는 IO-Handling이 주된 작업이었습니다. 각 작업의 특성을 생각해본다면 원인을 유추해낼수 있습니다. CPU-Bound 작업은 연산이 지속적으로 이루어지깄때문에 싱글 스레드 기반에서는 Context-switching 할 여유가 없습니다. 하지만 IO-Bound 작업은 대부분의 시간을 대기시간으로 보내게 되고 이때 GIL은 해제됩니다. 해제됨과 동시에 다른 스레드가 실행됩니다.</p>
<p>그렇다면 파이썬에서 CPU-Bound 작업을 동시 처리할 수 있는 무언가는 없을까요?</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><ul>
<li><strong>cpu/2process.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_work</span><span class="params">(start, end, result)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(start), int(end)):</span><br><span class="line">        sum += i</span><br><span class="line">    result.put(sum)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    START, END = <span class="number">0</span>, <span class="number">100000000</span></span><br><span class="line">    result = Queue()</span><br><span class="line">    st = time.time()</span><br><span class="line">    pr1 = Process(target=do_work, args=(START, END / <span class="number">2</span>, result))</span><br><span class="line">    pr2 = Process(target=do_work, args=(END / <span class="number">2</span>, END, result))</span><br><span class="line">    pr1.start()</span><br><span class="line">    pr2.start()</span><br><span class="line">    pr1.join()</span><br><span class="line">    pr2.join()</span><br><span class="line">    result.put(<span class="string">'STOP'</span>)</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        tmp = result.get()</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">'STOP'</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: sum += tmp</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'==sum:&#123;&#125;, running time &#123;:.4f&#125;s'</span>.format(sum, time.time() - st)) <span class="comment">#  3.9502s</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>cpu/1thread.py</code>의 실행시간 8.9s에 비해 3.9s라는 1/2 정도의 실행시간이 걸렸습니다. 실행시간 단축이 주는 의미를 풀어보자면 동시에 두 가지 작업이 함께 진행되었을 것입니다. 위 코드가 CPU-Bound 중심의 작업을 처리하기때문에 특별히 wating time을 갖지 않습니다. 결국 두개의 프로세스가 계속적으로 연산을 처리하지 않았다면 <code>cpu/1thread.py</code>와 비슷한 실행시간이 걸렸을 것입니다.</p>
<p><code>multiprocessing</code> 은 스레드 대신 하위 프로세스를 사용하여 GIL 효율적으로 회피합니다. 결론부터 말하자면 우리가 원하던 병렬처리가 가능해집니다. 각 프로세스는 독립된 메모리공간을 갖고 동시에 진행되며, 결국 프로그래머는 컴퓨터 상의 다중 프로세스를 완벽하게 활용할 수 있게됩니다. (물론 완벽한 병렬처리가 진행되려면 컴퓨터가 다중코어여야 합니다.)</p>
<h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><p>asyncio 는 파이썬 3.4 에서 새롭게 추가된 비동기 I/O 패키지입니다. asyncio 패키지는 이벤트루프에 운용되는 코루틴을 이용해서 동시성을 구현합니다. 이번 포스팅에 담기에는 방대한 내용이기에 구현 방법만 살펴보겠습니다. 자세한 내용은 아래 링크를 살펴보시면 도움이 될것입니다.</p>
<p><a href="http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html" target="_blank" rel="external">PYTHON: GENERATORS, COROUTINES, NATIVE COROUTINES AND ASYNC/AWAIT
</a><br><a href="http://b.ssut.me/58" target="_blank" rel="external">Python3, asyncio와 놀아보기</a></p>
<ul>
<li><strong>io/2asyncio.py</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'http://www.naver.com'</span>,</span><br><span class="line">       <span class="string">'https://www.google.com'</span>,</span><br><span class="line">       <span class="string">'https://www.apple.com'</span>,</span><br><span class="line">       <span class="string">'http://www.bing.com/'</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'Start with'</span>, url)</span><br><span class="line">    res = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.request(<span class="string">'GET'</span>, url)</span><br><span class="line">    res.close()</span><br><span class="line">    print(<span class="string">'End'</span>, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st = time.time()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_all</span><span class="params">(urls)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    fetchs = [fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    wait_coro = asyncio.wait(fetchs)</span><br><span class="line">    loop.run_until_complete(wait_coro)</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fetch_all(urls)</span><br><span class="line">print(<span class="string">"duration(s):&#123;:.4f&#125;"</span>.format(time.time() - st))</span><br><span class="line"><span class="comment"># duration(s):0.8603</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(참고: <code>asyncio</code>는 TCP와 UDP 프로토콜만 지원합니다. HTTP 등의 프로토콜을 지원하려면 <code>aiohttp</code>와 같은 서드파티 패키지가 필요합니다.)</p>
<p><code>asycnio</code>는 아래 그림과 같은 방식의 이벤트 루프를 중심으로 운용되며 이벤트 루프가 큐에 있는 코루틴을 하나씩 활성화하는 단일 스레드 프로그램입니다. 이러한 개념을 기억해주시고 코드를 살펴보면 이해하는데 도움이 될것입니다.</p>
<img src="/2016/12/11/Concurrency-in-Python/eventloop.png" alt="EventLoop" title="EventLoop">
<p>각 url을 파라미터로 받는 <code>fetch()</code> coroutine 을 list에 담아 <code>asyncio.wait(fetchs)</code> 함수에 넘겨줍니다. <code>asyncio.wait()</code>은 넘겨준 리스트의 coroutine을 이벤트루프가 스케줄링 가능한 Task Object로 warapping합니다. 이벤트 루프가 테스크를 모두 완료하고 프로그램은 종료됩니다. 실행시간은 0.9s가 걸렸습니다. 절차식 코드나 스레드 코드에 비하면 엄청난 속도 개선입니다. 물론 스레드 워커수를 가용가능한 최대치로 설정 후 실행한다면 속도는 비슷하게 나오리라 예상됩니다. 하지만 스레드로 복잡한 프로그램을  구현해 보셨다면 스레드의 스케줄링이 얼마나 어려운 작업인지 잘 아실 것입니다. 락을 잠고, 블락당하지 않게 해야 합니다. 하지만 코루틴기반의 <code>asyncio</code>의 사용은 개발자가 <code>yield</code> 명시만으로도 스케줄링이 가능하고 방해받지 않습니다.</p>
<p>실제로 <code>asyncio</code>는 내부적으로는 커널 수준까지 내려가는 저수준 스레드에 의존하지만, 패키지 사용자 즉 개발자는 스레드를 생성하거나 내부적으로 스레드가 사용되고 있다는 사실을 알 필요가 없습니다. 어플리케이션 수준에서 단지 우리가 작성한 코드가 블로킹되지 않게 보장하면 되며, 이벤트 루프가 동시성에 대한 나머지 모든 작업을 처리해줍니다. 결국 개발자가 스레드를 관리할 필요성을 제거함으로써 멀티스레드 시스템보다 더 많은 동시성 연결을 쉽게 관리할 수 있습니다.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>파이썬에서의 동시성 구현 방법들에 관하여 살펴보았습니다. 동시성 관련 개념들은 점점 더 중요해지고 있습니다. 그 이유는 다들 아시겠지만 과거 개발환경은 대부분 멀티쓰레딩 환경에서 하나의 CPU를 효율적으로 공유하도록 만드는데 초점이 있었습니다. 하지만 현재 멀티코어 시대에는 기존 방식으로는 성능향상의 한계가 있습니다. 그렇기에 병렬, 비동기 프로그래밍, 분산 컴퓨팅, 함수형 프로그래밍, 빅테이터, 인공지능 등 다양한 기술들이 동시성 패러다임과 함께 발달하고 있습니다.</p>
<p>Concurrent in Python 한정적인 주제로 진행했지만, 제가 전달하고 싶은 내용은 단순히 구현하는 방법이 아닌 <strong>동시성 관점과 사고를 갖고 개발할 수 있는 개발자가 되자!</strong> 입니다.</p>
<p>PS. 이렇게 인생의 첫 세미나가 이렇게 끝났네요. 느낀 점은 사용하는 것과 아는 것은 다르고, 가르침은 또 다른 범위의 문제라는 것을 깨달았습니다. 분량조절과 범위선정은 정말 어려웠습니다. 관련된 개념은 너무 많은데 주어진 시간에 정확한 내용을 전달하려면 무엇을 간략히 하고 정리해야할지… 미숙함이 많은 세미나였고, 내용이었지만 개인적으로는 정말 좋은 경험이 되었습니다. 40km 유격 행군보다 몇배는 힘든 세미나 준비였지만 이 문장을 끝으로 마무리하겠습니다. 감사합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://www.slideshare.net/dabeaz/an-introduction-to-python-concurrency" target="_blank" rel="external">An Introduction to Python Concurrency</a></li>
<li><a href="http://masnun.rocks/2016/10/06/async-python-the-different-forms-of-concurrency/" target="_blank" rel="external">Async python</a></li>
<li><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=8781382" target="_blank" rel="external">책: Fluent Python</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을 수 있습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><ul>
<li><a href="/2016/07/24/python-asyncio-Tasks/" title="python-asyncio-Tasks">python-asyncio-Tasks</a></li>
<li><a href="/2016/07/05/Python-Asyncio/" title="Python- yield, generator, coroutine">Python- yield, generator, coroutine</a>
<br></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;안녕하세요. SELO 입니다. 저희 회사에서는 격주 단위로 개발세미나를 진행하는데요. 개발자가 자유롭게 주제를 선택하여 세미나를 진행한답니다. 최근에 개인적으로 관심을 두고 있던 Concurrency에 관하여 세미나를 진행하게 되었고, 그 내용을
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="Concurrency" scheme="https://selo77.github.io/tags/Concurrency/"/>
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="asyncio" scheme="https://selo77.github.io/tags/asyncio/"/>
    
      <category term="thread" scheme="https://selo77.github.io/tags/thread/"/>
    
      <category term="multiprocess" scheme="https://selo77.github.io/tags/multiprocess/"/>
    
  </entry>
  
  <entry>
    <title>Keybox 개발기1 (pyenv와 virtualenv django 개발환경 셋팅)</title>
    <link href="https://selo77.github.io/2016/10/15/django-pyenv-virtualenv-settings/"/>
    <id>https://selo77.github.io/2016/10/15/django-pyenv-virtualenv-settings/</id>
    <published>2016-10-15T06:37:00.000Z</published>
    <updated>2016-10-15T06:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Keybox 란 어떤 용어나 개념을 한문장으로 요약해 학습하기 위한 웹 어플리케이션.</p>
<p>PS. 아래 내용은 개인 정리를 위해 작성된 포스트이므로 많은 부분이 생략되어있습니다. 궁금한 부부에 대한 질문은 댓글을 남겨주시면 시간되는대로 답변드리겠습니다.</p>
<h2 id="파이썬-그리고-장고-개발환경-셋팅"><a href="#파이썬-그리고-장고-개발환경-셋팅" class="headerlink" title="파이썬 그리고 장고 개발환경 셋팅"></a>파이썬 그리고 장고 개발환경 셋팅</h2><p>pyenv, virtualenv 를 활용한 개발환경 가상환경 셋팅. 한 피씨에서 하나의 특정 어플리케이션만 개발한다면 가상환경이 필요하지 않을지도 모릅니다. 하지만 저와 같이 여러 파이썬 프로젝트를 함께 진행한다면 가상 환경 셋팅은 모든 파이썬 개발의 필수적인 시작 과정입니다.</p>
<h3 id="Python-가상환경-셋팅-pyenv-virtualenv"><a href="#Python-가상환경-셋팅-pyenv-virtualenv" class="headerlink" title="Python 가상환경 셋팅 (pyenv, virtualenv)"></a>Python 가상환경 셋팅 (pyenv, virtualenv)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv global 3.5.0</span><br><span class="line">$ python -V</span><br><span class="line">Python 3.5.0</span><br><span class="line">$ mkdir keybox</span><br><span class="line">$ <span class="built_in">cd</span> keybox</span><br><span class="line">$ virtualenv venv</span><br><span class="line">Using base prefix <span class="string">'/Users/selochanlee/.pyenv/versions/3.5.0'</span></span><br><span class="line">New python executable <span class="keyword">in</span> /Users/selochanlee/Documents/github/keybox/venv/bin/python3.5</span><br><span class="line">Also creating executable <span class="keyword">in</span> /Users/selochanlee/Documents/github/keybox/venv/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure>
<p>저는 한 PC에서 여러 버전의 파이썬, 특히 2.7.8 과 3.5.0, 을 사용합니다. 이러한 문제를 쉽게 해결해주는 pyenv tool을 사용해 위와 같이 개발환경 셋팅을 합니다. 위와 같이 pc의 python version을 3.5.0으로 셋팅 후 프로젝트의 독립적인 개발환경을 위해 <code>virtualenv &lt;원하는 가상환경 이름&gt;</code>를 이용해 가상환경을 만듭니다.</p>
<h3 id="install-django-framework"><a href="#install-django-framework" class="headerlink" title="install django framework"></a>install django framework</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> venv/bin/activate <span class="comment"># 가상 환경 실행</span></span><br><span class="line">(venv) $ <span class="comment"># 실행 후 Command창 prefix가 붙음, (&lt;virtualenv_name&gt;)$</span></span><br><span class="line">(venv) $ pip install -U django</span><br><span class="line">Collecting django</span><br><span class="line">  Downloading Django-1.10.2-py2.py3-none-any.whl (6.8MB)</span><br><span class="line">    100% |████████████████████████████████| 6.8MB 204kB/s</span><br><span class="line">Installing collected packages: django</span><br><span class="line">Successfully installed django-1.10.2</span><br><span class="line"></span><br><span class="line">(venv) $ pip list</span><br><span class="line">Django (1.10.2)</span><br><span class="line">pip (8.1.2)</span><br><span class="line">setuptools (28.5.0)</span><br><span class="line">wheel (0.30.0a0)</span><br></pre></td></tr></table></figure>
<p><code>pip install</code>를 이용하여 django 최신 버전을 설치합니다. 정상적으로 설치가 됬는지 <code>pip list</code> 명령어를 이용해 확인합니다.</p>
<h2 id="장고-프로젝트-생성"><a href="#장고-프로젝트-생성" class="headerlink" title="장고 프로젝트 생성"></a>장고 프로젝트 생성</h2><p>위의 내용을 모두 진행하셨다면, 파이썬 기반의 장고 웹프레임웍을 사용하요 개발할 수 있는 환경이 끝나셨습니다. 약을 좀 팔자면 명령어 한줄로 웹 어플리케이션을 생성하실수 있습니다. 무슨 말인지는 아래 내용을 보시게 되면 이해가 될겁니다.</p>
<h3 id="장고-프로젝트-생성-1"><a href="#장고-프로젝트-생성-1" class="headerlink" title="장고 프로젝트 생성"></a>장고 프로젝트 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ django-admin <span class="built_in">help</span></span><br><span class="line">Type <span class="string">'django-admin help &lt;subcommand&gt;'</span> <span class="keyword">for</span> <span class="built_in">help</span> on a specific subcommand.</span><br><span class="line"></span><br><span class="line">Available subcommands:</span><br><span class="line"></span><br><span class="line">[django]</span><br><span class="line">    check</span><br><span class="line">    compilemessages</span><br><span class="line">    createcachetable</span><br><span class="line">    dbshell</span><br><span class="line">    diffsettings</span><br><span class="line">    dumpdata</span><br><span class="line">    flush</span><br><span class="line">    inspectdb</span><br><span class="line">    loaddata</span><br><span class="line">    makemessages</span><br><span class="line">    makemigrations</span><br><span class="line">    migrate</span><br><span class="line">    runserver</span><br><span class="line">    sendtestemail</span><br><span class="line">    shell</span><br><span class="line">    showmigrations</span><br><span class="line">    sqlflush</span><br><span class="line">    sqlmigrate</span><br><span class="line">    sqlsequencereset</span><br><span class="line">    squashmigrations</span><br><span class="line">    startapp</span><br><span class="line">    startproject</span><br><span class="line">    <span class="built_in">test</span></span><br><span class="line">    testserver</span><br></pre></td></tr></table></figure>
<p>장고는 메인 커맨드 <code>django-admin</code>에 어떤 명령어가 있는지 살펴보았습니다. 아래에서 3번째 줄을 보면 우리가 필요한 명령어가 보이실 겁니다. 그럼 만들어 봅시다.</p>
<p>(커멘드 창이 바뀌었는데요. 옮겨 적는게 귀찮아져서…. 제 실제 커맨드를 복사 붙여넣기 한 부분이니 이해해주시기 바랍니다. 처음부터 그냥 이리할걸….)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv)  ✝  ~/Documents/github/keybox  django-admin startproject keybox</span><br><span class="line">(venv)  ✝  ~/Documents/github/keybox  ls</span><br><span class="line">keybox venv</span><br></pre></td></tr></table></figure>
<p>위의 과정을 진행하시면 kyebox라는 디렉토리가 생성된것을 보실수 있습니다. 그럼 같이 keybox 디렉토리에는 무엇이 들어있고, 무엇을 할수있는지 같이 살펴보겠습니다.</p>
<h3 id="manage-py"><a href="#manage-py" class="headerlink" title="manage.py"></a>manage.py</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(venv)  ✝  ~/Documents/github/keybox  <span class="built_in">cd</span> keybox</span><br><span class="line">(venv)  ✝  ~/Documents/github/keybox/keybox  ls</span><br><span class="line">keybox    manage.py</span><br><span class="line">(venv)  ✝  ~/Documents/github/keybox/keybox  python manage.py runserver</span><br><span class="line">Performing system checks...</span><br><span class="line"></span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line"></span><br><span class="line">You have 13 unapplied migration(s). Your project may not work properly until you apply the migrations <span class="keyword">for</span> app(s): admin, auth, contenttypes, sessions.</span><br><span class="line">Run <span class="string">'python manage.py migrate'</span> to apply them.</span><br><span class="line"></span><br><span class="line">October 15, 2016 - 06:22:08</span><br><span class="line">Django version 1.10.2, using settings <span class="string">'keybox.settings'</span></span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">Quit the server with CONTROL-C.</span><br></pre></td></tr></table></figure>
<p><code>cd keybox</code> 키박스 디렉토리로 들어가 <code>ls</code> 폴더에 들어있는 파일을 리스트 해보니 또 다른 <code>keybox</code> 폴더와 <code>manage.py</code>라는 파이썬 파일이 보입니다. <code>manage.py</code>파일은 장고 어플리케이션의 모든 명령을 통솔합니다. 더 쉽게 이해해보자면 리모컨이라 생각하시면됩니다. <code>manage.py</code> 라는 장고 어플리케이션 리모콘에는 여러가지 버튼이 있습니다. 그 중 저는 <code>runserver</code>라는 버튼을 눌렀고, 버튼에 해당하는 어플리케이션 기능이 작동했습니다.</p>
<p>그러면 제가 작동시킨 기능은 어떤 기능인지 확인해보겠습니다. 브라우저를 열고 <code>http://127.0.0.1:8000/</code>를 들어가시면 웹 어플리케이션이 작동하시는 것을 확인하실수 있습니다.</p>
<p>사실 개인 일일 해커톤으로 최대한 빠르게 어플리케이션을 개발하려는 계획 이었는데, 이렇게 글을 쓰다보니 저도 모르게 너무 말이 많아젔네요. 오늘은 여기서 마무리 하고 다음편은 할 수 있을지 없을지 모르지만 … 하게 된다면 본격 장고 어플리케이션 개발기가 되겠군요. 그럼 진짜 이만 ㅃㅃ</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>필자머릿속(rochan87@gmail.com)</li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Keybox 란 어떤 용어나 개념을 한문장으로 요약해 학습하기 위한 웹 어플리케이션.&lt;/p&gt;
&lt;p&gt;PS. 아래 내용은 개인 정리를 위해 작성된 포스트이므로 많은 부분이 생략되어있습니다. 궁금한 부부에 대한 질문은 댓글을 남겨주시면 시간되는대로 답
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Django" scheme="https://selo77.github.io/categories/Python/Django/"/>
    
    
      <category term="django" scheme="https://selo77.github.io/tags/django/"/>
    
      <category term="pyenv" scheme="https://selo77.github.io/tags/pyenv/"/>
    
      <category term="virtualenv" scheme="https://selo77.github.io/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>Django Custom data Migration</title>
    <link href="https://selo77.github.io/2016/10/12/django-database-migration1/"/>
    <id>https://selo77.github.io/2016/10/12/django-database-migration1/</id>
    <published>2016-10-11T16:37:59.000Z</published>
    <updated>2016-10-11T16:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>django 1.7 기준</p>
<h3 id="why-needs-custom-migration"><a href="#why-needs-custom-migration" class="headerlink" title="why needs custom migration?"></a>why needs custom migration?</h3><p>서비스 운영을 하다보면 버전이 바뀌거나, 테이블 Schema 가 바뀌거나, 데이터가 뻑나거나 등등 데이터 마이그레이션이 필요한 순간이 있습니다. 가장 쉬운 방법은 스크립트를 작성해 데이터를 수정하는 코드를 작성하는 것입니다. 하지만 장고 프레임웍에서는 그보다 안정적이며 관리하기 쉬운 방법을 제공합니다. 바로 아래에서 살펴볼 custom migration file을 작성하는 것입니다.</p>
<p>위에서 말했듯 장고에서 제공하는 database migration은 스크립트 작성을 통한 데이터 수정보다 한층 고차원 수준의 migration을 제공합니다. forwards와 backwards 함수를 통해 forward와 backward를 간편하게 구현 해주며, 다양한 옵션들을 통해 선택적 마이그레이션을 가능하게 해줍니다. 이번 포스팅에서는 가장 기본적인 사용법을 살펴보겠습니다.</p>
<h3 id="make-empty-migration-file"><a href="#make-empty-migration-file" class="headerlink" title="make empty migration file"></a>make empty migration file</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py makemigrations --empty &lt;app_name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="forwards-function"><a href="#forwards-function" class="headerlink" title="forwards function"></a>forwards function</h3><p>forwards migrations 요구사항 코드 작성</p>
<h3 id="backwards-function"><a href="#backwards-function" class="headerlink" title="backwards function"></a>backwards function</h3><p>backwards migrations 요구사항 코드 작성</p>
<h3 id="base-code"><a href="#base-code" class="headerlink" title="base code"></a>base code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models, migrations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forwards</span><span class="params">(apps, schema_editor)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backwards</span><span class="params">(apps, schema_editor)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Migration</span><span class="params">(migrations.Migration)</span>:</span></span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">        (<span class="string">'polls'</span>, <span class="string">'0008_auto_20161002_0608'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    operations = [</span><br><span class="line">        migrations.RunPython(forwards,</span><br><span class="line">                             backwards)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<h3 id="migrate-commands"><a href="#migrate-commands" class="headerlink" title="migrate commands"></a>migrate commands</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py migrate [app_name]</span><br></pre></td></tr></table></figure>
<h3 id="migrate-backwards-command"><a href="#migrate-backwards-command" class="headerlink" title="migrate backwards command"></a>migrate backwards command</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py migrate &lt;app_name&gt; &lt;migration_file_name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://docs.djangoproject.com/en/1.10/howto/writing-migrations/" target="_blank" rel="external">Writing database migrations</a> - django database migrations official document</li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있씁니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;django 1.7 기준&lt;/p&gt;
&lt;h3 id=&quot;why-needs-custom-migration&quot;&gt;&lt;a href=&quot;#why-needs-custom-migration&quot; class=&quot;headerlink&quot; title=&quot;why needs custom mi
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Network (제1장 웹과 네트워크의 기본에 대해 알아보자) 대화형 정리</title>
    <link href="https://selo77.github.io/2016/10/09/HTTP-1-TCP-IP-Layer/"/>
    <id>https://selo77.github.io/2016/10/09/HTTP-1-TCP-IP-Layer/</id>
    <published>2016-10-09T12:05:10.000Z</published>
    <updated>2016-10-09T13:49:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://selo77.github.io/2016/10/09/HTTP-1-TCP-IP-Layer/s.svg" alt="HTTP"></p>
<h2 id="HTTP는-무엇인가"><a href="#HTTP는-무엇인가" class="headerlink" title="HTTP는 무엇인가?"></a>HTTP는 무엇인가?</h2><p><strong>HTTP(HyperText Transfer Protocol)</strong> is an appointment. 클라이언트에서 서버까지의 일련의 흐름을 정해놓은 약속. 무슨말이냐면, 그런거야. 음 영화에서 모스부호로 막 비밀얘기하자나 그런거랑 비슷한데 웹상에서 정보를 전달하기 위해 정해놓은 약속 이라 생각하면 쉬울거야. 그냥 웹상에서의 약속이라고 넘어가면돼 이런 추상적인 개념을 한번에 이해한다면 넌 인터스텔라!!</p>
<h2 id="HTTP는-왜-배워야할까"><a href="#HTTP는-왜-배워야할까" class="headerlink" title="HTTP는 왜 배워야할까?"></a>HTTP는 왜 배워야할까?</h2><p>근데 HTTP를 왜 배워야할까? <strong>겁나 재미없자나</strong> 다른것들은 막 이것저것 만들면 짠하고 멋지기도 하고 근데 HTTP는 영 그런 꿀잼도 없고 … 그런데 있자나 우리 같은 개발자가 어플리케이션을 만들자나 그런데 우리가 만든 어플리케이션을 웹상에서 서비스하고 싶어 그렇다면 뭐가 달라질까? 바로 웹이라는 환경에서 우리의 어플리케이션에 사용자가 URL로 접근하게 만들고, 로그인하고 세션설정하고, 쿠키셋팅하고, 인증, 보안 그외 에도 이것저것 막 하게돼 그런것들이 가능하게 된 것은 바로 HTTP라는 약속이 존재하기 때문이지. 물론 이전에 네트워크 개념이 들어가겠지만 말이야. 그래서 너가 웹 분야에서 고급진 기능을 구현하고 이해하는 개발자가 되고 싶자나 그러면 너는 이것을 꼭 공부해야 할거야. 그래 그러면 공부하자 ㅇㅋ?</p>
<h2 id="네트워크의-기본은-TCP-IP"><a href="#네트워크의-기본은-TCP-IP" class="headerlink" title="네트워크의 기본은 TCP/IP"></a>네트워크의 기본은 TCP/IP</h2><p>뭐야 HTTP 공부한다면서 짜증나게 왠 네트워크야!!!!</p>
<p>어 미안…ㅠㅠ HTTP를 이해하기 위해서는 TCP/IP 마스터는 아니어도 기본정도는 알아야 HTTP를 이해하는데도 도움이 되거든 … 그러니 조금만 참아줘.</p>
<h3 id="TCP-IP-란"><a href="#TCP-IP-란" class="headerlink" title="TCP/IP 란?"></a>TCP/IP 란?</h3><p>일반적으로 인터넷을 포함한 우리가 언급하는 네트워크의 대부분은 TCP/IP라는 프로토콜 상에서 작동하고 있어. HTTP는 그 중 하나야.</p>
<p>아니 무슨말이냐. HTTP가 이미 프로토콜이라며 ㅡㅡ? 근데 왜 또 TCP/IP 도 프로토콜인데 짜증나!! 너 나랑 장난해!!?</p>
<p>잠시만 기달려봐 아직 내말 끝난게 아니야… 컴퓨터와 네트워크 기기가 상호간에 통신을 하기 위해서는 서로 같은 방법으로 통신하지 않으면 안돼. 쉽게 설명하자면 이런거야 너가 어떤 미지의 외계인이랑 성공적인 대화를 원한다고 치자. 어떻게 해야 성공적인 대화(통신)이 이루어질 수 있을까? 바로 사전에 어떤 언어를 사용하여, 어떤 통신 채널을 이용하여, 어떤 이야기를 진행해야 할지 규칙을 정할 필요가 있을거야.</p>
<p>  <strong>이렇듯 서로 다른 하드웨어와 운영체제 등(각기 다른 외계 종적)을 가지고 서로 통신을 하기 위해서는 모든 요소에 규칙이 필요한 것이란 말이지. 이러한 규칙이 프로토콜이며, 인터넷에 관련된 이러한 프로토콜들의 집합을 TCP/IP라 말할수 있지!!!!</strong></p>
<p>  TCP/IP 프로토콜에는 우리가 한번쯤 들어봤을 만한 FTP, DNS, HTTP, IP, SNMP 등 포함되어 있어. 포기하지마 친구.</p>
<h3 id="TCP-IP-계층"><a href="#TCP-IP-계층" class="headerlink" title="TCP/IP 계층"></a>TCP/IP 계층</h3><p>TCP/IP에서 꼭 이해해야할 개념 중 하나가 계층(Layer)이야. 개발을 하다보면 계층을 나누는게 얼마나 중요한지 본능적으로 깨닫는 순간이 있어. 예를 들자면 Interface의 개념을 이해하는 순간, 혹은 Service Layer와 Persistance Layer의 필요성을 이해하는 순간 등… 사실 나도 직관적으로 이해할뿐 설명하라면 버버벅 어렵더라.ㅠㅠ 아무튼 계층화를 하는 이유는 분명 메리트가 있어서 일거란 말이지.</p>
<p>계층을 나눌때 가장 큰 장점은 유지보수야. 계층이 나누어저 있지 않다면, 정해진 약속이 하나의 변경이 전체의 변경으로 이루어 질 수 있지, 하지만 계층들을 독립적으로 나누어 놓았다면 변경을 요하는 계층과 인접한 계층만 변경하면 될거야.</p>
<p>계층은 대충이해했고, TCP/IP는 어떻게 계층을 나눴다는거야?</p>
<p>오 좋은 질문이야!!! TCIP/IP의 계층들은 기능적으로 잘 분리되어 있어. 4가지 계층으로 나눌 수 있는데 아래에 간략히 정리해 놓을게.</p>
<ul>
<li>어플리케이션 계층 - 클라이언트와 가장 가까운 프로토콜들이 활동하는 어플리케이션 계층으로서 어느 웹 페이지를 보고 싶다라는 HTTP Request를 만드는 등 클라이언트의 요구사항을 규칙에 맞게 정리하는 역할을 합니다. HTTP, DNS, FTP 등 우리와 친숙한 어플리케이션과 프로토콜 이 포함되어 있어.</li>
<li>트랜스포트 계층 - 어플리케이션 계층에서 받은 데이터를 통신하기 쉽게 조각내어 안내번호와 포트 번호를 붙여 네트워크 계층에 전달합니다.</li>
<li>네트워크 계층 - 네트워크 상에서 패킷의 이동을 다룹니다. 패킷이란 정송하는 데이터의 최소 단위입니다. 인터넷의 경우 request를 보내는 컴퓨터에 도달하기 까지의 길을 결정하는 역할을 합니다.</li>
<li>링크 계층 - 네트워크에 접속하는 하드웨어적인 면을 다룹니다. 데이터 링크 계층, 혹은 네트워크 인터페이스 계층이라도 부릅니다. 저와 같은 경우는 하드웨어와 운영체제를 연결하는 인터페이스 계층으로 이해했습니다.</li>
</ul>
<h3 id="HTTP와-친근한-프로토콜들-IP-TCP-DNS"><a href="#HTTP와-친근한-프로토콜들-IP-TCP-DNS" class="headerlink" title="HTTP와 친근한 프로토콜들 IP/TCP/DNS"></a>HTTP와 친근한 프로토콜들 IP/TCP/DNS</h3><p>이번 포스팅의 마지막 주제로 HTTP와 친구들을 공부해볼까해. 이 친구들은 HTTP와 아주 긴밀한 관계를 맺고 있기 때문에 공부가 필요해.</p>
<p><a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C" target="_blank" rel="external">IP</a> - 먼저 이 친구들 중 짱을 맞고 있는 IP에 대해 살펴보자. IP는 TCP/IP라는 명칭의 일부가 될 정도로 중요한 프로토콜 이야. 위키에 IP는 아래와 같이 정의되있어</p>
<blockquote>
<p>인터넷 프로토콜(IP, Internet Protocol)은 송신 호스트와 수신 호스트가 패킷 교환 네트워크(패킷 스위칭 네트워크, Packet Switching Network)에서 정보를 주고받는 데 사용하는 정보 위주의 규약(프로토콜, Protocol)이며, OSI 네트워크 계층에서 호스트의 주소지정과 패킷 분할 및 조립 기능을 담당한다. 줄여서 아이피(IP)라고도 한다.</p>
</blockquote>
<p>와우 이게 무슨 어매이징한 멍멍스러운 소리일까????!! 송신, 수신, 호스트, 패킷, 규약 ㅣㅇ나ㅓ리ㅆㅃ. 침착하자. HTTP 스터디를 시작할때 다짐하지 않았던가 이 정도 시련은…</p>
<p>아마도 앞에 공부한 맥락을 보고 IP의 정의를 유추해보자. 인터넷상에서 패킷이라는 데이터의 최소 단위로 정보를 주고 받으며, 이를 상대방에게 보내기 위해 미리 정해놓은 약속 쯤으로 생각하고 넘어가자. 시간이 우리의 관계를 해결해줄 것이라 믿으며…</p>
<p><a href="https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C" target="_blank" rel="external">TCP</a> - 다음은 2짱 TCP 프로토콜이다. 우리 2짱 TCP 형님은 Tansmission Control Protocol, 전송제어프로토콜, 이름에서도 알수 있듯이 트랜스포트(전송) 계층에 속하며 위키의 정의를 살펴보자.</p>
<blockquote>
<p>전송 제어 프로토콜(Transmission Control Protocol, TCP, 문화어: 전송조종규약)은 인터넷 프로토콜 스위트(IP)의 핵심 프로토콜 중 하나로, IP와 함께 TCP/IP라는 명칭으로도 널리 불린다. TCP는 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다. TCP는 전송 계층에 위치한다. 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜의 하나로서 국제 인터넷 표준화 기구(IETF)의 RFC 793에 기술되어 있다.</p>
</blockquote>
<p>역시나 정체 모를 외계음성이 들린다… 침착해. 키워드를 뽑아보자. 전송? 제어? 옥텟? 전송계층? 정보전달을 통제? 음… 역시나 멍멍멍. 아이큐 100이상인 원숭이 보다 똑똑한 머리로 유추를 해보자면,</p>
<p>TCP 프로토콜은 사전 약속이다. 어떤 약속? 1바이트(옥텟)를 안정적으로, 순선대로, 에러없이 교환 할 수 있게 하는 사전 약속. 다시 한번 정리하자면, Transmission Control Protocol은 데이터를 안정적으로, 순서대로 교환 할 수 있게 해주는 전송 계층에서의 사전 규약이다.</p>
<p><a href="https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C" target="_blank" rel="external">DNS</a> - 마지막은 빵셔틀을 담당하는 DNS(Domain Name System) 친구를 알아보자. 헐 까페가 끝날 시간이란다. 시간이 없다ㅠㅠ. 빠르게 정리해보자. 위키의 정의를 보자.</p>
<blockquote>
<p>도메인 네임 시스템(Domain Name System, DNS)은 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었다. 특정 컴퓨터(또는 네트워크로 연결된 임의의 장치)의 주소를 찾기 위해, 사람이 이해하기 쉬운 도메인 이름을 숫자로 된 식별 번호(IP 주소)로 변환해준다. 도메인 네임 시스템은 흔히 “전화번호부”에 비유된다. 인터넷 도메인 주소 체계로서 TCP/IP의 응용에서, www.example.com과 같은 주 컴퓨터의 도메인 이름을 192.168.1.0과 같은 IP 주소로 변환하고 라우팅 정보를 제공하는 분산형 데이터베이스 시스템이다.</p>
</blockquote>
<p>이 빵셔틀 친구는 심플하게 전화번호부 하나로 설명이 끝난다.  구글에 접속하기 위해 192.312.233.1 을 치는 것보다 google.com을 치는것이 편하다. 바로 이것이 DNS 존재의 이유다. 호스트 도메인의 이름(<a href="https://www.google.com)을" target="_blank" rel="external">https://www.google.com)을</a> 네트워크 주소(192.312.233.1)로 바꾸거나 그 반대 변환의 수행하는 역할을 한다.</p>
<p>이런 간단히 정리한다는게 내면의 나와 대화를 하다보니 불필요한 내용도 많이 첨가되고 했지만, 초보 새로새로에게 많은 도움이 됐으면 좋겠다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>Book - 그림으로 배우는 HTTP Network</li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/07/17/How-to-solve-as-meeting-blankpage/" title="프로덕션 환경에서 블랭크 페이지를 만난다면?">프로덕션 환경에서 블랭크 페이지를 만난다면?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://selo77.github.io/2016/10/09/HTTP-1-TCP-IP-Layer/s.svg&quot; alt=&quot;HTTP&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;HTTP는-무엇인가&quot;&gt;&lt;a href=&quot;#HTTP는-무엇인가&quot; class=
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
    
      <category term="HTTP" scheme="https://selo77.github.io/tags/HTTP/"/>
    
      <category term="TCP/IP" scheme="https://selo77.github.io/tags/TCP-IP/"/>
    
      <category term="DNS" scheme="https://selo77.github.io/tags/DNS/"/>
    
      <category term="TCP/IP Layer" scheme="https://selo77.github.io/tags/TCP-IP-Layer/"/>
    
  </entry>
  
  <entry>
    <title>Python -  == 와 is 의 차이</title>
    <link href="https://selo77.github.io/2016/10/04/python-deference-is-and-equal/"/>
    <id>https://selo77.github.io/2016/10/04/python-deference-is-and-equal/</id>
    <published>2016-10-03T15:04:18.000Z</published>
    <updated>2016-10-11T16:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python은 직관적이고 하이레벨 프로그래밍 언어입니다. 이에 맞게 우리가 쓰는 언어에 가까운 문법이 존재합니다. 그 중에 오늘은 is 와 == 의 차이를 공부해보겠습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>things = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>things[:]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>things == things[:]</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>things와 things[:] 값을 비교하였고, True를 반환 받았습니다. 그렇다면 is를 사용하여 한번더 비교해보겠습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>things <span class="keyword">is</span> things[:]</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>리턴값이 False 입니다. is 와 == 을 이해하고 사용하시는 분이라면 당연한 결과라 말씀하시겠지만 Python을 사용하여 돈을 벌고 있음에도 불구하고 저는 문제를 마딱드리기 전까지 차이를 모르고 사용했습니다. 물론 직관적으로 어느 부분에 is를 사용하고  ==을 사용해야 할지 판단했기때문에 문제(버그)에 직면하지 않았습니다. 갑자기 “똥인지 된장인지 구분못하고 쓰면안된다” 는 저의 개발 스승님 말씀이 떠오르네요…</p>
<p>위 결과값의 차이를 보니 확실히 is 와 == 이 뭔가는 다른것 같습니다. 그렇다면 무엇이 다를까요? 이를 확인하기 위해 어떤 방법을 동원해볼까요?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name == <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>이번에는 둘다 같은 True를 반환했네요. 그렇다면 첫번째 주어진 조건과 두번째 조건의 차이를 알수 있다면, is 와  == 의 차이를 알수 있을것 같은 느낌이 드네요.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(things)</span><br><span class="line"><span class="number">4556601824</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(things[:])</span><br><span class="line"><span class="number">4556641344</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(name)</span><br><span class="line"><span class="number">4554182552</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="keyword">None</span>)</span><br><span class="line"><span class="number">4554182552</span></span><br></pre></td></tr></table></figure>
<p>파이썬에 내장 함수인 id()를 이용해 메모리상의 주소값을 비교해보았습니다. 결과값을 보니 is 와 == 의 차이가 뭔지 아시겠나요?</p>
<p>첫번째 소스의 things 와 things[:] 를 is 로 비교했을때 False를 반환했던 이유는 객체의 주소가 달랐기 때문입니다. things의 주소는  4556601824 이고, things[:] 는 4556641344 입니다. 공부를 하면서 얻은 보너스!!! [:] 처리는 Call by value 가 아니라 Call by Reference 처리라는 것도 알 수 있습니다.</p>
<p>정리하자면 Python에서 == 는 Value를 자체를 비교하는 연산자 이고, is 는 객체의 주소(object identity)를 비교하는 키워드 혹은 비교연산자라는 것을 알수있습니다.</p>
<p>오늘 공부 끝~! 부족한글 읽어주셔서 감사합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://stackoverflow.com/questions/14247373/python-none-comparison-should-i-use-is-or" target="_blank" rel="external">Python None comparison: should I use “is” or ==?</a><br><em>
</em></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있씁니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python은 직관적이고 하이레벨 프로그래밍 언어입니다. 이에 맞게 우리가 쓰는 언어에 가까운 문법이 존재합니다. 그 중에 오늘은 is 와 == 의 차이를 공부해보겠습니다.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;ta
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Regex by re module (파이썬 정규식 활용)</title>
    <link href="https://selo77.github.io/2016/09/25/python-regex/"/>
    <id>https://selo77.github.io/2016/09/25/python-regex/</id>
    <published>2016-09-24T17:14:52.000Z</published>
    <updated>2016-10-03T15:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="정규식은-왜-필요한가"><a href="#정규식은-왜-필요한가" class="headerlink" title="정규식은 왜 필요한가?"></a>정규식은 왜 필요한가?</h2><p>정규식은 문자열 파싱을 위해 존재합니다. 정규식이 없어도 문자열 파싱은 가능합니다. 하지만 정규식은 복잡한 파싱을 혁신적으로 간단하게 만들어줍니다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>특정한 규칙을 가진 집합을 표현</li>
<li>문자열의 검색이나 치환에 편리.</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.youtube.com/watch?v=kWyoYtvJpe4" target="_blank" rel="external">Google Python Class Day 2 Part 1:Regular Expressions.</a></li>
<li><a href="https://www.youtube.com/watch?v=pkcTEoUexag&amp;list=PLZPhyNeJvHRnSJ2sAnqCGFnVRKo98EgCp&amp;index=4" target="_blank" rel="external">Regular expression [A-Z]+ - PyCon APAC 2016 - 양민지</a></li>
<li><a href="https://wikidocs.net/1642" target="_blank" rel="external">점프 투 파이썬</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있씁니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/06/23/Python-definition/" title="Python - Python?">Python - Python?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;정규식은-왜-필요한가&quot;&gt;&lt;a href=&quot;#정규식은-왜-필요한가&quot; class=&quot;headerlink&quot; title=&quot;정규식은 왜 필요한가?&quot;&gt;&lt;/a&gt;정규식은 왜 필요한가?&lt;/h2&gt;&lt;p&gt;정규식은 문자열 파싱을 위해 존재합니다. 정규식이 없어도 
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="Python" scheme="https://selo77.github.io/tags/Python/"/>
    
      <category term="Regex" scheme="https://selo77.github.io/tags/Regex/"/>
    
      <category term="RegularExpression" scheme="https://selo77.github.io/tags/RegularExpression/"/>
    
  </entry>
  
  <entry>
    <title>Python datetime module(class datetime, timedelta ...)</title>
    <link href="https://selo77.github.io/2016/09/02/python-datetime-strftime-example/"/>
    <id>https://selo77.github.io/2016/09/02/python-datetime-strftime-example/</id>
    <published>2016-09-02T02:49:32.000Z</published>
    <updated>2016-09-04T07:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="들어가기전에"><a href="#들어가기전에" class="headerlink" title="들어가기전에"></a>들어가기전에</h2><p>파이썬으로 하는 개발이 즐거운 이유중 하나는 강력한 내장 모듈입니다. 3.3부터 추가된 asyncio(제가 가장 좋아하는 모듈입니다.)!! 혹은 multiprocessing, logging, sys, os 등등등 왠만해서는 3rd Library 필요없이 구현이 가능합니다. 오늘은 이런 강력한 모듈 중 하나인 datetime에 관하여 살펴보겠습니다.</p>
<p>날짜와 시간 처리는 개발자에게 상당한 고민을 요구합니다. 특히 글로벌 서비스의 경우는 시간대 설정이 매우 종요합니다. 서비스 하는 국가가 섬머타임 정책까지 사용한다면 ??? 나ㅣ어ㅣ만어ㅣ만어ㅣ ㅇㅇ아ㅣ너ㅣㅏㄴ어리ㅓㅏ !!!!!! 하지만 걱정안하셔도 됩니다. 이미 똑똑한 선구자들께서는 이미 우리를 위해 길을 만들어 놓으셨답니다.</p>
<h2 id="datetime-Objects"><a href="#datetime-Objects" class="headerlink" title="datetime Objects"></a>datetime Objects</h2><p>datetime 모듈은 모듈 이름 그대로 날짜와 시간의 조작에 관한 거의 모든 기능을 제공합니다. 구구절절 설명 보다는 코드를 보면서 살펴봅시다~. 아래 코드는 기록을 위해 texteditor를 사용하였습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> type(datetime) <span class="comment"># module</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> datetime(year=<span class="number">2016</span>, month=<span class="number">10</span>, day=<span class="number">23</span>) <span class="comment"># 2016-10-23 00:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def __init__(self, year, month, day, hour=None, minute=None, second=None, microsecond=None, tzinfo=None): # real signature unknown; restored from __doc__</span></span><br></pre></td></tr></table></figure>
<p>먼저 말씀드렸다 싶이 datetime 자체는 모듈 패키지로서, 다양한 Class를 갖고 있습니다. 그 중 핵심이 되는 class datetime를 기반으로 다양한 연산과 활용이 가능하답니다.( module datetime 과 class datetime이 이름이 똑같은 이유는 아마도 이러한 이유가 아닐까 생각합니다. ) datetime의 생성자를 살펴보면 기본적으로 년, 월, 일 3가지 인자를 initial value를 인자로 받아 상태값을 셋팅합니다. 여기서 중요한 부분은 tzinfo=none 입니다. 제가 현재 일하는 회사에서는 30개국을 대상으로 서비스를 진행하는데, 국가에 따라 tzinfo를 설정 따로 GMT +A 를 계산할 필요가 없습니다.(서머타임 예외) <strong>Key point: datetime모듈의 핵심 클래스는 class datetime이다. Why? datetime모듈을 사용은 단순히 날짜와 시간을 확인하기 보다는 날짜와 시간 연산을 위해 사용하는 경우가 대부분입니다. 그렇기에 datetime 객체는 연산을 위한 핵심 type 입니다. type이 정확하지 않은 경우 TypeError를 맞이하겠죠!</strong></p>
<p>아래에서는 제가 주로 사용하는 datetime의 메소드를 살펴보겠습니다.</p>
<h3 id="strptime-과-strftime"><a href="#strptime-과-strftime" class="headerlink" title="strptime() 과 strftime()"></a>strptime() 과 strftime()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybirthday_str = datetime.strftime(mybirthday_datetime, <span class="string">"%Y/%m/%d %H:%M:%S"</span>)</span><br><span class="line"><span class="keyword">print</span> mybirthday_str <span class="comment"># 1987/04/13 00:00:00</span></span><br><span class="line"><span class="keyword">print</span> type(mybirthday_str) <span class="comment"># &lt;type 'str'&gt;</span></span><br></pre></td></tr></table></figure>
<p>strftime() 은 datetime object와 format(날짜형식)을 입력 받아, 입력받은 format에 맞는 string object로 반환해줍니다. 이와 반대로 strptime()은 string object와 format을 입력 받아 datetime object로 캐스팅 해줍니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">now_str = <span class="string">"2016-09-02 21:31:30"</span></span><br><span class="line">now_datetime = datetime.strptime(now_str, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"><span class="keyword">print</span> type(now_datetime) <span class="comment"># &lt;type 'datetime.datetime'&gt;</span></span><br></pre></td></tr></table></figure>
<p>하지만 여기서 끝난다면 파이썬 내장모듈이라기에 약한 느낌이죠?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> datetime.strftime(now_datetime, <span class="string">"%y %B %A %p %I/ week number of the year: %W"</span>)</span><br><span class="line"><span class="comment"># 16 September Friday PM 09/ week number of the year: 35</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 다양한 Directive로 데이터를 표현할 수도 있답니다. 결론, 캐스팅 헬퍼 메소드의 구현 과정없이 내장 모듈을 사용하시면 되겠습니다!!<br>아 참고로 strftime()는 datetime 뿐만 아니라 date, time objects 모두 지원합니다.</p>
<p><a href="https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior" target="_blank" rel="external">Python API: strftime &amp; strptime </a></p>
<h2 id="timedelta-Objects"><a href="#timedelta-Objects" class="headerlink" title="timedelta Objects"></a>timedelta Objects</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">today_datetime = datetime.today()</span><br><span class="line"><span class="keyword">print</span> today_datetime <span class="comment"># 2016-09-02 22:38:09.543477</span></span><br><span class="line">one_weeks = timedelta(weeks=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># days=None, seconds=None, microseconds=None, milliseconds=None, minutes=None, hours=None, weeks=None</span></span><br><span class="line">one_weeks_ago = today_datetime - one_weeks</span><br><span class="line"><span class="keyword">print</span> one_weeks_ago <span class="comment"># 2016-08-26 22:38:09.543477</span></span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 timedelta Object를 사용하면 날짜 시간 연산을 직관적으로 해결할 수 있도록 도와줍니다.</p>
<h2 id="tzinfo-Objects"><a href="#tzinfo-Objects" class="headerlink" title="tzinfo Objects"></a>tzinfo Objects</h2><p>만약 제공하는 서비스가 우리나라로 국한된다면 tzinfo 오브젝트 까지 굳이 사용은 필요는 없습니다. 서버가 해외에 있는 경우는 조금 다르지만… 하지만 글로벌 서비스를 하거나 특정 timezone 구현이 필요하다면 !!! tzinfo objects를 활용하면 원하는 timezone objects를 만들어 사용할수 있습니다.</p>
<h2 id="date-time-Objects"><a href="#date-time-Objects" class="headerlink" title="date, time Objects"></a>date, time Objects</h2><p>위 Objects 이외에도 date, time Objects가 존재하지만 저같은 경우는 datetime Objects로 대부분 처리 함으로 이 Objects에 대한 설명은 생략하도록 하겠습니다. 원하시는 분은 아래 Reference의 datetime module API를 살펴보시기 바랍니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>datetime module에는 정말 많은 기능들이 내장되어 있습니다. 잘찾아 잘쓰시면 됩니다….!!<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"><span class="keyword">print</span> now <span class="comment"># 2016-09-04 16:33:11.164451</span></span><br><span class="line"></span><br><span class="line">now_date = now.date()</span><br><span class="line"><span class="keyword">print</span> now_date <span class="comment"># 2016-09-04</span></span><br><span class="line"><span class="keyword">print</span> type(now_date) <span class="comment"># &lt;type 'datetime.date'&gt;</span></span><br><span class="line"></span><br><span class="line">now = now.replace(year=<span class="number">2000</span>)</span><br><span class="line"><span class="keyword">print</span> now <span class="comment"># 2000-09-04 16:35:03.646963</span></span><br><span class="line"></span><br><span class="line">d = datetime.date(<span class="number">1987</span>, <span class="number">04</span>, <span class="number">13</span>)</span><br><span class="line">t = datetime.time(<span class="number">01</span>, <span class="number">01</span>, <span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">dt = datetime.datetime.combine(d, t)</span><br><span class="line"><span class="keyword">print</span> dt</span><br><span class="line"></span><br><span class="line">dt_tuple = dt.timetuple()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dt_tuple:</span><br><span class="line">  <span class="keyword">print</span> i</span><br><span class="line">  <span class="comment"># 1987</span></span><br><span class="line">  <span class="comment"># 4</span></span><br><span class="line">  <span class="comment"># 13</span></span><br><span class="line">  <span class="comment"># 1</span></span><br><span class="line">  <span class="comment"># 1</span></span><br><span class="line">  <span class="comment"># 59</span></span><br><span class="line">  <span class="comment"># 0</span></span><br><span class="line">  <span class="comment"># 103</span></span><br><span class="line">  <span class="comment"># -1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://overapi.com/python" target="_blank" rel="external">overapi/python</a></li>
<li><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="external">python module datetime api</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다. 포스팅의 첫번째 목적은 작성자의 학습이므로 Context가 틀어지는 경우가 있을수 있씁니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/06/23/Python-definition/" title="Python - Python?">Python - Python?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;들어가기전에&quot;&gt;&lt;a href=&quot;#들어가기전에&quot; class=&quot;headerlink&quot; title=&quot;들어가기전에&quot;&gt;&lt;/a&gt;들어가기전에&lt;/h2&gt;&lt;p&gt;파이썬으로 하는 개발이 즐거운 이유중 하나는 강력한 내장 모듈입니다. 3.3부터 추가된 async
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="datetime" scheme="https://selo77.github.io/tags/datetime/"/>
    
      <category term="strftime" scheme="https://selo77.github.io/tags/strftime/"/>
    
      <category term="strptime" scheme="https://selo77.github.io/tags/strptime/"/>
    
  </entry>
  
  <entry>
    <title>자료구조 기본 - 배열, 리스트, 스택, 큐, 트리, 그래프</title>
    <link href="https://selo77.github.io/2016/08/20/basic-datastructure/"/>
    <id>https://selo77.github.io/2016/08/20/basic-datastructure/</id>
    <published>2016-08-20T05:06:08.000Z</published>
    <updated>2016-08-21T09:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="자료구조-개념-정의"><a href="#자료구조-개념-정의" class="headerlink" title="자료구조 개념 정의"></a><strong>자료구조 개념 정의</strong></h2><p>이번 포스팅은 가장 흔히 접할 수 있는 자료구조에 대해 한줄 정리를 하는 간단한 포스팅이 될 예정입니다.</p>
<p>먼저 자료구조의 정의에 대해 간단히 집고 넘어가자면,</p>
<blockquote>
<p>자료구조(資料構造, 영어: data structure)는 전산학에서 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법이다.<br>출처 : [위키피디아 - 자료구조]: <a href="https://ko.wikipedia.org/wiki/자료_구조" target="_blank" rel="external">https://ko.wikipedia.org/wiki/자료_구조</a></p>
</blockquote>
<p>대량의 데이터를 효율적으로 관리하는 메커니즘이며, 현실 세계에서의 우편번호나 학교에서 학생번호가 대표적인 예가 될 수 있습니다.</p>
<p>예를 들면 학생이 1000명 있는 학교에서 특정 학생을 이름으로 찾으려면 최소 1회 최대 1000회의 노력이 들어갑니다. 하지만 우리는 이런 방식으로 학생을 찾지 않습니다. 1학년 2반 3번 이새로찬 이런식으로 찾게 됩니다. 어떤 학생이든 3회만에 찾을 수 있는 조건이 만들어 지게됩니다. 이렇듯 대량의 데이터를 효율적으로 관리하는 방식을 자료구조라 합니다.</p>
<p>컴퓨터에는 다양한 방식의 자료구조들이 존재하며, 프로그래밍 언어마다 내장된 기본 자료구조도 다릅니다. 그럼 이제 기본적인 자료구조를 살펴보러 가시죠. Here we go~!!</p>
<hr>
<h2 id="자료구조-종류-및-기본-개념"><a href="#자료구조-종류-및-기본-개념" class="headerlink" title="자료구조 종류 및 기본 개념"></a><strong>자료구조 종류 및 기본 개념</strong></h2><h3 id="배열"><a href="#배열" class="headerlink" title="배열"></a><strong>배열</strong></h3><p>컴퓨터 프로그래밍을 시작하면서 가장 먼저 접하게 되는 자료구조입니다. 배열은 데이터가 일직선상에 빈틈없이 나열한 자료구조 입니다. 여기서 키포인트는 빈틈없이 나열되 었다는 점입니다. 배열과 리스트를 헷갈려하시는 분들이 있는데 이 부분은 리스트에서 추가 설명드리겠습니다.<br><img src="https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcTzU4dUSHmTVAun3GaQMfX3fLZWJdgxbGIu9uxtWOGSrCXT5yzkw1b6Ku0"></p>
<h3 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a><strong>리스트</strong></h3><p>데이터가 순차적으로 나열된 자료구조 입니다. 배열과 같이 나열된 데이터를 관리 한다는 부분에서 혼란을 줍니다. 하지만 배열과 리스트의 그림을 보면서 이해하면 차이점이 좀 더 명확히 이해되실겁니다. 배열은 나열된 데이터를 인덱스(쉽게 설명하자면 박스의 이름)으로 데이터를 색인(검색) 가능하다면 리스트는 포인터(쉽게 생각하자면 연결 빨대)로 서로 연결되 있으며, 포인터(연결 빨대)를 통해 검색이 이루어 질 수 있습니다. 그럼 한 가지 질문을 드리자면 <strong>특정 Index(위치)를 검색할때 배열과 리스트 중 어느 자료구조의 평균 검색속도가 빠를까요?</strong></p>
<p><img src="http://cfile3.uf.tistory.com/image/1338A04A4F9948D9378E81"></p>
<h3 id="스택"><a href="#스택" class="headerlink" title="스택"></a><strong>스택</strong></h3><p>스택 == 쌓다. 단어 뜻 그대로 쌓이는 자료구조입니다. 스택의 경우는 크게 두가지 액션을 갖는데 푸쉬와 팝입니다. 말그대로 데이터를 푸쉬 집어넣고, 팝 꺼냅니다. 이게 다입니다!! 먼저 들어간 데이터가 가장 나중에 나오게 되는 스택(<strong>FILO</strong>: FIRST IN, LAST OUT.). 자료구조는 어느 곳에 사용하면 효율적일까요?<br><img src="http://1.bp.blogspot.com/-L-wZpwPSGfw/UI79Cpd_iMI/AAAAAAAAAw8/25VRkQU7fgc/s1600/s.png"></p>
<h3 id="큐"><a href="#큐" class="headerlink" title="큐"></a><strong>큐</strong></h3><p>큐는 스택과 반대되는 개념으로 1차선 터널을 생각하시면 됩니다. 1차선 터널에서 먼저 들어간 차가 먼저 나오게 될 것입니다.(<strong>FIFO</strong>: FIRST IN, FIRST OUT) 이러헌 큐(대기행렬)는 어떤 데이터 관리에 효율적일까요?</p>
<p><img src="http://cfile28.uf.tistory.com/image/26606738537BF2F836AF58"></p>
<h3 id="이진-트리"><a href="#이진-트리" class="headerlink" title="이진 트리"></a><strong>이진 트리</strong></h3><p>이진트리는 다음 요소(노드)를 가리키는 포인트를 2개 갖는 단방향 리스트의 일종이라고 할 수 있습니다. 상위노드를 부모노드 라 하며 하위노드를 자식노드라 합니다. 가장 최상위 노드를 뿌리라 하며 최하위 노드를 잎(리프)라고 부릅니다.<br><img src="http://cfile6.uf.tistory.com/image/2321CB4951A467AC0B97C5"></p>
<ul>
<li><strong>힙(HEAP)</strong> - 부모노드의 값이 자식노드의 값보다 항상 작은(또는 항상 큰) 규칙을 갖는 이진 트리를 힙이라 합니다.</li>
</ul>
<h3 id="그래프"><a href="#그래프" class="headerlink" title="그래프"></a><strong>그래프</strong></h3><p>마지막 그래프입니다. 기본적으로 그래프는 아래그림에서 보시다 시피 각항 목을 의미하는 정점(노드)와 정점의 관계를 표현하는 간선으로 구성된 자료구조입니다. 한 마디로 데이터의 관계를 노드와 엣지로 표현한 자료구조입니다. 검색 시스템에서 많이 사용되는 자료구조입니다. 간단히 설명하자면 검색단어를 검색하고, 검색단어에 해당하는 노드에 연결된 노드들을 이어주는 간선의 가중치나 관계를 파악함으로서 검색결과를 다양하게 뽑아낼수 있게됩니다.</p>
<p><img src="http://cfile9.uf.tistory.com/image/172F48394F0A45181824C0"></p>
<hr>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>사실 자료구조만 띡!! 놓고 학습하면 생각보다 각각의 자료구조들이 어디에 사용되고 사용해야할지 의문이 많이듭니다. 그래서 저는 이를 학습하는 방법으로 자료구조를 직접 구현해볼 예정입니다. 사실 저에게 자료구조와 알고리즘 학습은 많은 인내를 요구합니다. 대부분의 다른분들도 그러리라 생각됩니다. 하지만 앞선 포스팅 <a href="/2016/08/11/datastructure-basic/" title="자료구조 알고리즘은 꼭 필요한 것인가?">자료구조 알고리즘은 꼭 필요한 것인가?</a> 의 정신을 다시한번 되세기며 자료구조와 알고리즘을 내 코딩에 자연스럽게 녹여내는 날까지. 화이팅입니다!!</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>책 - <a href="http://book.naver.com/bookdb/book_detail.nhn?bid=10741278" target="_blank" rel="external">그림으로 배우는 알고리즘 Basic</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<hr>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/08/11/datastructure-basic/" title="자료구조 알고리즘은 꼭 필요한 것인가?">자료구조 알고리즘은 꼭 필요한 것인가?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;자료구조-개념-정의&quot;&gt;&lt;a href=&quot;#자료구조-개념-정의&quot; class=&quot;headerlink&quot; title=&quot;자료구조 개념 정의&quot;&gt;&lt;/a&gt;&lt;strong&gt;자료구조 개념 정의&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;이번 포스팅은 가장 흔히 접할
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Datastructure" scheme="https://selo77.github.io/tags/Datastructure/"/>
    
      <category term="Queue" scheme="https://selo77.github.io/tags/Queue/"/>
    
      <category term="Stack" scheme="https://selo77.github.io/tags/Stack/"/>
    
      <category term="Binary Tree" scheme="https://selo77.github.io/tags/Binary-Tree/"/>
    
      <category term="Graph" scheme="https://selo77.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>자료구조 알고리즘은 꼭 필요한 것인가?</title>
    <link href="https://selo77.github.io/2016/08/11/datastructure-basic/"/>
    <id>https://selo77.github.io/2016/08/11/datastructure-basic/</id>
    <published>2016-08-11T07:46:18.000Z</published>
    <updated>2016-12-17T08:17:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="자료구조-알고리즘은-꼭-필요한-것인가"><a href="#자료구조-알고리즘은-꼭-필요한-것인가" class="headerlink" title="자료구조 알고리즘은 꼭 필요한 것인가?"></a>자료구조 알고리즘은 꼭 필요한 것인가?</h2><p>저는 사파 개발자 입니다. 제가 정의한 사파 개발자라함은 비전공자로서 체계적인 학습을 받지 못한 상태에서 개발에 입문한 개발자를 말합니다. 사실 사파와 정파를 나누다는 것 자체가 제 자신이 부족하다는 증거일 것입니다. 하지만 주니어 개발자 단계에서는 사파와 정파의 차이는 분명 존재합니다. 특히 기반지식들에서는 큰 차이와 출발지점 자체가 다릅니다. 그 중 자료구조와 알고리즘은 무림에 갓 입문한 사파 개발자에게 아주 큰 벽이자 애증의 관계입니다. 그 대표로 제 자신이 존재합니다.</p>
<p>제 경험을 빗대어 얘기해보자면, 회사에서 신규 서비스를 개발할 때 2명의 API 개발자 중 한명으로 투입된 적이 있었습니다. 지금도 입문자 수준이지만 이 당시에는 알고리즘과 자료구조에 대한 지식이 전무했습니다. 하지만 3개월의 개발기간 동안 문제 없이 개발을 진행했고, 오픈까지 성공적으로 완수 했습니다.</p>
<p>‘그래서 너가 하고 싶은 말이 뭐냐?’</p>
<p>음 뭐냐면요… 복잡한 알고리즘이 필요 없는 서비스에서는 자료구조와 알고리즘에 대한 이해가 크게 중요하지 않습니다. 특히 트래픽이 폭팔적으로 많지 않다면 남아도는 서버의 자원이 있다면 더더욱 중요하지 않습니다. 오히려 이 단계에서는 알고리즘과 자료구조에 대한 이해 보다는 코드의 재사용성에 대한 이해와 가독성이 훨씬 중요할 것이라 생각됩니다.</p>
<p>‘뭐지 이 자식 지는 자료구조와 알고리즘에 대해 포스팅하고 있으면서 왜 자꾸 필요없다는 말을 하는거지?!! 뭐 어쩌라고?!’</p>
<p><strong>어느 정도 수준의 서비스는 자료구조와 알고리즘이 이해 없이도 꾀 잘 만들수 있다는 믿음은 변함없습니다. 어느 정도로 잘 만들어진 제품을 100점 만점에 80점이라 가정했을 때, 자신이 받은 점수가 80점으로 만족하는 개발자라면 자료구조와 알고리즘을 굳이 공부할 필요가 없다 생각합니다. 80점을 만드는 개발자가 나쁜 것이 아닙니다. 어느 상황에서는 100점 보다 80점 제품이 기업에서 요구하는 수준일 수 있습니다. 60점을 80점으로 만드는 비용과 80점을 100점으로 향상시키는 비용은 비교가 되지 않을 만큼 더 클 것이기 때문입니다. 학창시절 만점을 맞기 위해 투자하는 노력과 80점을 맞기 투자한 노력의 차이와 같은 맥락일 것입니다.</strong></p>
<p>결국 본인이 80점 이상의 제품을 만들기 원하는 기업에 들어가고 싶다거나 본인 스스로 80점이상의 제품을 만들고 싶다면 자료구조와 알고리즘과 같은 기초지식?들이 필요합니다.</p>
<p>서론이 엄청 길었네요… 자료구조와 알고리즘과 오랜 싸움을 위해서 어느 정도의 동기부여와 각오가 제 스스로 필요했던 것 같습니다. <strong>사파든 정파든 개발자의 길을 선택했고, 100점 짜리 제품을 만들 수 있는 고수가 되기 위해서 저는 알고리즘과 자료구조를 공부합니다!!</strong> 주저리 끝!! 이제 공부하러 갑시다!!</p>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><ul>
<li><p><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관</a>,</p>
</li>
<li><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회</a>
</li>
</ul>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;자료구조-알고리즘은-꼭-필요한-것인가&quot;&gt;&lt;a href=&quot;#자료구조-알고리즘은-꼭-필요한-것인가&quot; class=&quot;headerlink&quot; title=&quot;자료구조 알고리즘은 꼭 필요한 것인가?&quot;&gt;&lt;/a&gt;자료구조 알고리즘은 꼭 필요한 것인가?&lt;/h2
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://selo77.github.io/tags/Algorithm/"/>
    
      <category term="Queue" scheme="https://selo77.github.io/tags/Queue/"/>
    
      <category term="Stack" scheme="https://selo77.github.io/tags/Stack/"/>
    
      <category term="Graph" scheme="https://selo77.github.io/tags/Graph/"/>
    
      <category term="datastructure" scheme="https://selo77.github.io/tags/datastructure/"/>
    
      <category term="Array" scheme="https://selo77.github.io/tags/Array/"/>
    
      <category term="List" scheme="https://selo77.github.io/tags/List/"/>
    
      <category term="Tree" scheme="https://selo77.github.io/tags/Tree/"/>
    
      <category term="HashMap" scheme="https://selo77.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>The Django Beginning (MVC Vs MTV)</title>
    <link href="https://selo77.github.io/2016/08/01/what-is-django/"/>
    <id>https://selo77.github.io/2016/08/01/what-is-django/</id>
    <published>2016-08-01T11:44:09.000Z</published>
    <updated>2016-08-03T13:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django란"><a href="#Django란" class="headerlink" title="Django란?"></a>Django란?</h2><p>장고는 Python에서 사용하는 가장 대표적인 웹 프레임웍 입니다. 자바에 스프링, 루비에 레일스가 있다면 파이썬에는 그 이름도 특이한 <a href="https://www.djangoproject.com/" target="_blank" rel="external">장고</a>!! 가 존재합니다.</p>
<p>장고는 기본적으로 <a href="https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC" target="_blank" rel="external">MVC Architecture pattern</a>을 따릅니다. MVC 패턴은 웹 프레임웍에서 가장 많이 체택되는 디자인 패턴중 하나로서 역할에 따른 소스 코드의 분리로 많은 장점들을 갖게 됩니다. 장고는 MTV(Model Template View)는 디자인 패턴을 따르지만 이는 MVC 패턴의 일부로 생각합니다. 그럼 먼저 장고의 기본 아키텍처를 보고 넘어가겠습니다.<br><img src="/2016/08/01/what-is-django/Django_mvc.png" alt="Django Basic Architecture" title="Django Basic Architecture"><br><img src="/2016/08/01/what-is-django/MVCBasic.jpg" alt="Spring MVC Architecture" title="Spring MVC Architecture"><br>첫번째 다이어그램은 장고의 MTV 패턴이 적용된 아키텍처이며, 아래는 Java Spring의 MVC 아키텍처 입니다. 사실 장고가 뭔지도 잘 모르는데 아키텍처를 먼저 보는 이유는 무작정 코드를 작성하는 것보다 아키텍처 다이어그램을 머리에 세기고, 코드를 작성하면 데이터 흐름을 어느 정도 이해할수 있기 때문입니다. 또한 세부적인 코드가 전체에서 어느 부분에 영향을 미치게 되는지 이해를 도와줍니다.</p>
<h2 id="MVC-Vs-MTV"><a href="#MVC-Vs-MTV" class="headerlink" title="MVC Vs MTV"></a>MVC Vs MTV</h2><p>MVC 와 Django MTV를 비교를 통해 정리해보겠습니다. 먼저 MVC부터 살펴 보면 데이터베이스와 interaction은 <strong>Model</strong> 에서 처리하고, Business Logic은 <strong>Controller</strong>, User Interface의 생성은 <strong>View</strong> 에서 각각 처리합니다. (위의 다이어그램과 함께) 전체적 흐름을 살펴보자면 Request에 해당하는 컨트롤러를 호출하고, 컨트롤러는 request의 응답에 필요한 데이터를 찾기 위해서 적절한 Model을 소환합니다!! 최종적으로 View를 호출 Model에서 얻은 데이터를 토대로 사용자에게 보낼 User Interface를 구성 후 Response를 보내게 됩니다.</p>
<p>그렇다면 장고의 MTV는 뭐가 다를까요? 뭐가 다르기에 MTV라고 부르는 것일까요? MTV는 MVC를 약간 수정한  패턴입니다. MTV의 <strong>Model</strong> 은 MVC Model과 같은 역할을 합니다. 데이터 베이스와 데이트 추출을 담당 합니다. Django는 기본적으로 <a href="http://debop.blogspot.kr/2012/02/orm-object-relational-mapping.html" target="_blank" rel="external">ORM(Object Relational Mapping)</a> 테크닉을 지원합니다. ORM방식의 지원으로 개발자는 SQL의 작성 작업의 대부분으로 부터 자유로워 지며, OOP 개발에 집중할 수 있게 도와줍니다.<br> <strong>View</strong> 는 MVC의 Controller와 같은 Business Logic을 처리합니다. 마지막으로 <strong>Template</strong> 은 Client에게 보여질 User Interface를 구현하며, Django Template은 스크립트 언어인 Python의 장점을 극대화 시킨 강력한 templating system을 제공합니다. Middleware, URL Resolver Template Loader 부분은 당장 구현이 필요한 부분은 아니므로 넘어가셔도 상관없습니다.</p>
<img src="/2016/08/01/what-is-django/jumpstart-django-42-728.jpg" alt="Django Basic Architecture" title="Django Basic Architecture">
<p>위 다이어그램의 데이터 흐름과 함께 MTV 각각의 역할을 생각하시면 전체적인 그림이 그려지실 겁니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>파이썬의 강력한 웹 프레임웍 장고에 대해 살펴보았습니다. 장고는 MVC 패턴의 장점을 살리면서 빠른 생산을 위한 MTV 패턴을 채택하였습니다. 또한 ORM 테크를 지원하여 객체지향적인 코드 생산에만 전념할 수 있도록 도와줍니다. 또한 위에서 설명하지는 않았지만 깊은 역사?와 함께 수많은 지원 패키지들이 존재합니다. 이러한 수많은 장점 덕분에 스타트업에서 선호하는 웹 프레임웍 중 탑 순위권 안에 들었으며, 점점 더 많은 채택을 받으며 발전하고 있습니다. 아직은 어렵게 다가올수 있지만, 장고 프레임웍 하나만 제대로 이해해도 먹고 사는데는 지장이 없으리라 생각됩니다 흐흐.</p>
<p>Ps. 아마도 다음 포스팅은 장고 공식 사이트의 튜토리얼을 통해 간단한 여론조사 어플리케이션을 만들어 볼 예정입니다~.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://bharatikunal.wordpress.com/2009/03/11/introduction-to-django/" target="_blank" rel="external">Introduction to Django</a></li>
<li><a href="https://docs.python.org/3/tutorial/modules.html#tut-packages" target="_blank" rel="external">more abount python packages</a></li>
<li><a href="https://devissue.wordpress.com/2015/02/01/pycharm%EA%B3%BC-%ED%95%A8%EA%BB%98-django%EC%99%80-restframework%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/" target="_blank" rel="external">PyCharm과 함께 DJango와 RestFramework를 활용한 웹 사이트 구축하기</a></li>
<li><a href="http://pythoninreal.blogspot.kr/2013/12/virtualenv.html" target="_blank" rel="external">virtualenv를 사용하자 - 가상 개발환경 구축하기</a></li>
<li><a href="https://www.jetbrains.com/help/pycharm/2016.1/adding-existing-virtual-environment.html" target="_blank" rel="external">Adding Existing Virtual Environment on PyCharm</a></li>
<li><a href="https://docs.djangoproject.com/en/1.10/misc/design-philosophies/#dry" target="_blank" rel="external">Django Design philosophies</a></li>
<li><a href="http://www.javajigi.net/pages/viewpage.action?pageId=6560" target="_blank" rel="external">ORM의 기본적인 개념 및 활용방안</a></li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<!-- ## Related Posts

<p><br/> –&gt;</p>
-->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Django란&quot;&gt;&lt;a href=&quot;#Django란&quot; class=&quot;headerlink&quot; title=&quot;Django란?&quot;&gt;&lt;/a&gt;Django란?&lt;/h2&gt;&lt;p&gt;장고는 Python에서 사용하는 가장 대표적인 웹 프레임웍 입니다. 자바에 스프링, 루
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Django" scheme="https://selo77.github.io/categories/Python/Django/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="Django" scheme="https://selo77.github.io/tags/Django/"/>
    
      <category term="MTV" scheme="https://selo77.github.io/tags/MTV/"/>
    
      <category term="MVC" scheme="https://selo77.github.io/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>python-asyncio-Tasks</title>
    <link href="https://selo77.github.io/2016/07/24/python-asyncio-Tasks/"/>
    <id>https://selo77.github.io/2016/07/24/python-asyncio-Tasks/</id>
    <published>2016-07-24T09:04:17.000Z</published>
    <updated>2016-07-24T09:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio Sample for MyMusicTaste</span></span><br><span class="line"><span class="comment"># SELO77</span></span><br><span class="line"><span class="comment"># 2016-07-24</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpwanClass</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @asyncio.coroutine</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self, request_class_list)</span>:</span></span><br><span class="line">    response = []</span><br><span class="line">    <span class="keyword">if</span> request_class_list:</span><br><span class="line"><span class="meta">      @asyncio.coroutine</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(request_class)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">          result = <span class="keyword">yield</span> <span class="keyword">from</span> request_class.execute()</span><br><span class="line">          response.append(result)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">          print(traceback.format_exc())</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        tasks_list = []</span><br><span class="line">        <span class="keyword">for</span> each_class <span class="keyword">in</span> request_class_list:</span><br><span class="line">          tasks_list.append(</span><br><span class="line">            asyncio.Task(run(each_class))</span><br><span class="line">          )</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.gather(*tasks_list)</span><br><span class="line">      <span class="keyword">except</span>:</span><br><span class="line">        print(traceback.format_exc())</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestClass1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'RequestClass1.__init()__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @asyncio.coroutine</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"class1_response"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestClass2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'RequestClass2.__init()__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @asyncio.coroutine</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"class2_response"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    request_class_list = [RequestClass1(), RequestClass2()]</span><br><span class="line">    spwanClass = SpwanClass()</span><br><span class="line">    final_result = <span class="keyword">yield</span> <span class="keyword">from</span> spwanClass.execute(request_class_list)</span><br><span class="line">    print(<span class="string">"final_result:%s"</span>%final_result)</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">    print(traceback.format_exc())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>필자 머릿속</li>
</ul>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/07/05/Python-Asyncio/" title="Python- yield, generator, coroutine">Python- yield, generator, coroutine</a>
<a href="/2016/06/23/Python-definition/" title="Python - Python?">Python - Python?</a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="asyncio" scheme="https://selo77.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Docker 란?</title>
    <link href="https://selo77.github.io/2016/07/19/What-is-Docker/"/>
    <id>https://selo77.github.io/2016/07/19/What-is-Docker/</id>
    <published>2016-07-18T22:47:23.000Z</published>
    <updated>2016-07-20T13:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://d21ii91i3y6o6h.cloudfront.net/gallery_images/from_proof/1026/large/1396373089/docker.png"></p>
<h2 id="Docker-란"><a href="#Docker-란" class="headerlink" title="Docker 란?"></a>Docker 란?</h2><p><strong>도커란 컨테이너(이미지)를 실행 관리하고 배포하기 위한 기술입니다.</strong> 범위를 좁게 하면 리눅스 컨테이너를 관리하는 도구입니다. 리눅스 컨테이너? 자바에서 서블릿컨테이너, JSP컨테이너는 들어봤는데 리눅스도 컨테이너가 있네요. 제가 알고 있는 컨테이너는 자바 빈들을 실행하고 관리 하기 위해 존재 했었는데요.</p>
<blockquote>
<p><a href="https://ko.wikipedia.org/wiki/LXC" target="_blank" rel="external">리눅스 컨테이너(LXC)란</a> 단일 컨트롤 호스타 상에서 리눅스 시스템(컨테이너)를 실행하기 위한 위한 운영 시스템 레벨 가상화 방법</p>
</blockquote>
<p>리눅스 컨테이너는 <a href="https://access.redhat.com/documentation/ko-KR/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html" target="_blank" rel="external">Control Group(Cgroup)</a>와 <a href="http://bluese05.tistory.com/11" target="_blank" rel="external">namespace</a> 결합하여 애플리케이션을 위한 가상 환경을 제공합니다. Docker 또한 이러한 실행 환경을 갖게 되고 독립된 드라이버로서 작동할수 있게 됩니다. <strong>간단히 정리를 하자면 Docker는 Cgroup 기술로 Host OS 자원을 활용하고, namespace를 통해 독립된 실행 공간을 갖게 됩니다.</strong></p>
<h2 id="Docker-용어정리"><a href="#Docker-용어정리" class="headerlink" title="Docker 용어정리"></a>Docker 용어정리</h2><p>Docker(도커)의 개념을 이해했으면 Docker 내부적으로 사용되는 용어를 정리 해봅시다. 먼저 Docker의 환경의 전체적인 흐름을 살펴보실까요~</p>
<blockquote>
<p>도커 환경은 크게 도커 호스트와 도커 클라이언트로 생각해 볼 수 있습니다. 도커 호스트는 도커 데몬(도커 엔진?)을 기반으로 도커 컨테이너들을 실행 및 관리 합니다. 반면 도커 클라이언트는 도커 명령을 실행하는데 쉽게 이해하면 인터페이스로서 도커 이미지를 관리합니다.</p>
</blockquote>
<p>빠른 이해를 위해 기본 웹 환경과 대입해 이해해보겠습니다.</p>
<ul>
<li>도커 호스트는 도커 컨테이너를 실행하는 가상머신. (서버)</li>
<li>도커 클라이언트는 도커 Interface (클라이언트 프로그램)</li>
<li>도커 데몬은 도커 엔진 (서버 프로세스)</li>
<li>도커 컨테이너는 하나의 프로세스 (이미지의 인스턴스)</li>
<li>도커 이미지는 실행파일 (소스코드?)</li>
</ul>
<p>어느 정도 개념을 정리 했으니 도커 아키텍처를 보면서 구체화 시켜봅시다.</p>
<h2 id="Docker-Architecture"><a href="#Docker-Architecture" class="headerlink" title="Docker Architecture"></a>Docker Architecture</h2><ul>
<li><strong>간단한 Docker Architecture</strong><br><img src="http://southworks.com/blog/wp-content/uploads/sites/81/2015/07/docker_architecture.png"></li>
</ul>
<p><img src="http://nordicapis.com/wp-content/uploads/Docker-API-infographic-container-devops-nordic-apis.png"><br><br></p>
<ul>
<li><p><strong>기존의 가상머신 환경과 Docker의 차이</strong><br><img src="http://siliconangle.com/files/2014/08/Docker-vs-Virtualization.jpg"><br><br></p>
</li>
<li><p><strong>Docker Commands Diagram</strong><br><img src="https://philipzheng.gitbooks.io/docker_practice/content/_images/cmd_logic.png"><br><br></p>
</li>
<li><p><strong>Docker Renterprise Architecture</strong><br><img src="https://docs.opensvc.com/_images/docker.enterprise.architecture.png"></p>
</li>
</ul>
<h2 id="Docker-철학"><a href="#Docker-철학" class="headerlink" title="Docker 철학"></a>Docker 철학</h2><p><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="external">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></p>
<blockquote>
<p>Run only one process per container</p>
</blockquote>
<p>위 링크를 보시면 아래 문구의 Docker의 철학이 담겨있습니다. 그 이유는 한개의 이미지에 여러개의 프로세스를 넣으면 확장성과 재사용성이 급격히 저하가 됩니다. 물론 Docker 생태계가 확장하는데도 더 어려워 질것입니다. 이렇듯 그 기술의 철학에 맞게 사용하는것도 매우 중요합니다. 차후 Docker로 이미지를 Build하고 사용하면서 이 부분은 한번 더 집고 넘어가도록 하겠습니다.</p>
<h2 id="왜-Docker-인가"><a href="#왜-Docker-인가" class="headerlink" title="왜 Docker 인가?"></a>왜 Docker 인가?</h2><p>짧지만 핫하디 핫한 Docker(도커)를 살펴보았습니다. DevOps에 무뇌한인 저에게는 개발만이 전부가 아니다 라는 큰 방향을 일깨워주었고, 이렇게 편리한 Tool을 사용하지 않는 것은 죄악이다!! 라는 조금은 단순무식한 결론을 얻었습니다. 실제 프로덕션환경에서 사용경험은 전무하지만 단지 개념만 놓고 보았을때 결론입니다. Docker는 리눅스 컨테이너라는 기존의 <a href="https://ko.wikipedia.org/wiki/%ED%95%98%EC%9D%B4%ED%8D%BC%EB%B0%94%EC%9D%B4%EC%A0%80" target="_blank" rel="external">하이퍼바이저</a>라는 조금은 무거운 과정을 훨씬 가볍게 해주었으며, DevOps의 최전선 기술로 우리의 개발환경을 한층 윤택하게 만들어줄 것이라는 결론과 함께 Docker 살펴보기를 마무리 하겠습니다. 감사합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.iolo.kr/510" target="_blank" rel="external">docker getting started: 왕초보를 위한 docker 입문</a><br><a href="http://www.slideshare.net/pyrasis/docker-fordummies-44424016" target="_blank" rel="external">도커 무작정 따라하기</a><br><a href="http://documents.docker.co.kr/" target="_blank" rel="external">Docker 한글 문서 / 영상 모음집</a></p>
<p>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://d21ii91i3y6o6h.cloudfront.net/gallery_images/from_proof/1026/large/1396373089/docker.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker-란&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="DevEnv" scheme="https://selo77.github.io/categories/DevEnv/"/>
    
      <category term="Docker" scheme="https://selo77.github.io/categories/DevEnv/Docker/"/>
    
    
      <category term="Docker" scheme="https://selo77.github.io/tags/Docker/"/>
    
      <category term="CD" scheme="https://selo77.github.io/tags/CD/"/>
    
      <category term="DevOps" scheme="https://selo77.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>프로덕션 환경에서 블랭크 페이지를 만난다면?</title>
    <link href="https://selo77.github.io/2016/07/17/How-to-solve-as-meeting-blankpage/"/>
    <id>https://selo77.github.io/2016/07/17/How-to-solve-as-meeting-blankpage/</id>
    <published>2016-07-17T04:40:31.000Z</published>
    <updated>2016-08-03T01:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>현재 저의 역량을 벗어나는 문제를 맞닥뜨렸습니다. 다니고 싶은 회사에 지원을 했고, 파이썬 신의 기를 받아 서류합격을 했습니다. 기쁨도 잠시 인터뷰 진행 전 미션을 받았습니다. 그 중 첫 번째 미션을 정리하면서 최선의 답을 찾아보려합니다.</p>
<h2 id="문제의-이해"><a href="#문제의-이해" class="headerlink" title="문제의 이해"></a>문제의 이해</h2><blockquote>
<p><strong>프로덕션 환경에서 작동하는 WAS(웹 어플리케이션 서버)를 브라우저에서 접속하니 갑자기 블랭크 페이지가 뜹니다.<br>어떤 툴, 서비스 혹은 command를 사용하여 문제를 파악하고 해결할수 있는지 서술해주세요.</strong></p>
</blockquote>
<p>먼저 문제를 자세히 살펴 봅시다. 프로덕션 환경? 블랭크 페이지? 프로덕션 환경이란 실제 현재 서비스 중인 환경이며, 블랭크 페이지란 아래 이미지와 같은 페이지를 의미합니다.<br><img src="https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcRpXOqksDqlSBQaWJb9P0JtwAYskN_zfhxJWFNUX9XxQhewjGRshQ"><br>그렇다면 Blank Page가 뜨는 원인의 파악이 필요할 것이며 다음 단계에서 문제의 원인을 찾아보겠습니다.</p>
<h2 id="문제-원인-파악"><a href="#문제-원인-파악" class="headerlink" title="문제 원인 파악"></a>문제 원인 파악</h2><p>보통 문제에 직면했을때, 크게 두 가지 경우로 나눌 수 있습니다. 문제가 무엇인지 아는 경우와 문제가 무엇인지 모르는 경우입니다. 저는 두번째 경우에 가까웠습니다. 그래서 제가 활동하는 커뮤니티에 도움을 청했고 문제의 접근 방향을 설정 후 진행했습니다.</p>
<p>Blank Page의 원인은 크게 Client상의 문제와 Server상의 문제로 분류할 수 있습니다. 서버 문제의 경우 다양한 원인의 가능성이 있고, 원인을 찾기 위해서 크게 서버 상태확인, 로그 분석, 패킷 분석 등이 필요합니다.</p>
<pre><code>블랭크 페이지 원인 Case 정리
1. Client 문제
  1.1 브라우저
  1.2 악성코드
2. Server 문제
  2.1 WAS 문제
  2.2 네트워크(DNS, 인터넷) 문제
</code></pre><h2 id="문제-해결-단계-설정"><a href="#문제-해결-단계-설정" class="headerlink" title="문제 해결 단계 설정"></a>문제 해결 단계 설정</h2><pre><code>1. Client 문제
  1.1 브라우저 설정확인
  1.2 악성코드 감염 여부 확인
2. Server 문제
  - Server health check
  2.1 WAS 문제
    - WAS Log 분석
    - Packet 분석
  2.2 Network 문제
    - DNS 상태 확인
</code></pre><h2 id="문제-원인-분석"><a href="#문제-원인-분석" class="headerlink" title="문제 원인 분석"></a>문제 원인 분석</h2><h3 id="Client-문제"><a href="#Client-문제" class="headerlink" title="Client 문제"></a>Client 문제</h3><p>  첫번째 가정 Client가 원인인 경우 입니다. 이를 확인 하는 가장 쉬운 방법은 타 장비에서 Domain에 접속해 보는 것입니다. 타 장비에서 정상적 접근이 가능하다면 특정 장비의 문제입니다. 원인은 보통 개인 브라우저의 설정이 잘못되었거나 악성코드에 감염된 경우 입니다. 후자의 경우에는 브라우저 상에서 <a href="https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C" target="_blank" rel="external">DNS(Domain Name System)</a>를 임의로 통제하는 경우가 있습니다. 도메인 네임 시스템은 전화번호부 라고 생각하면 쉬운데 악성 바이러스가 전화번호부에 등록된 이름과 번호를 임의로 변경시키게 됩니다. 정리하자면 도메인 이름을 IP 주소로 변환하는 과정에서 정상적인 주소로의 변환이 이루어지지 않습니다. 이와 같은경우는 애드웨어나 백신 프로그램을 통해서 해결할 수 있습니다.</p>
<h3 id="Server-문제"><a href="#Server-문제" class="headerlink" title="Server 문제"></a>Server 문제</h3><p>서버 문제가 원인인 경우 훨씬 복잡합니다. 여기서 부터는 제 지식의 한계와 구체적인 설명을 위하여 스펙을 정의하고 진행하겠습니다.</p>
<ul>
<li>AWS EC2</li>
<li>Linux AMI</li>
<li>WAS - Nginx</li>
<li>로그 분석 환경 - ELKR (ElasticSearch + Logstash + Kibana + Redis)</li>
</ul>
<p>AWS Console에 접속해 Instance의 상태를 확인합니다. Instance의 상태가 정상이라면 Kibana Web에 접속에러 로그를 확인합니다. 블랭크 페이지에서 받았던 Response의  Status Code와 page byte size가 0인 Case를 검색 합니다. (검색 쿼리 예: @fields.status:502 &amp;&amp; @fields.size:537)</p>
<p>케이스를 확인 했으니 Wireshark(패킷 분석툴)를 이용하여 케이스를 테스트 하고 원인을 파악합니다. 이 단계에서 네트워크 통신 과정에서 패킷유실이 있는지도 확인합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><ul>
<li><a href="http://brantiffy.axisj.com/archives/418" target="_blank" rel="external">ELKR (ElasticSearch + Logstash + Kibana + Redis) 를 이용한 로그분석 환경 구축하기</a></li>
<li><a href="http://inverlist.postype.com/post/78617/" target="_blank" rel="external">Wireshark를 통한 패킷 분석</a><h3 id="도움을-주신분들"><a href="#도움을-주신분들" class="headerlink" title="도움을 주신분들"></a>도움을 주신분들</h3></li>
<li>Facebook Group 모여서 각장 코딩하는 모임</li>
<li>스타트업 개발자 모임 인간님</li>
<li>나는 프로그래머다의 Jaeyong_Cho 님</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;현재 저의 역량을 벗어나는 문제를 맞닥뜨렸습니다. 다니고 싶은 회사에 지원을 했고, 파이썬 신의 기를 받아 서류합격을 했습니다. 기쁨도 잠시 인터뷰 진행 전 미션을 받았습니다. 그 중 첫 번째 미션을 정리하면서 최선의 답을 찾아보려합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="DevEnv" scheme="https://selo77.github.io/categories/DevEnv/"/>
    
      <category term="ETC" scheme="https://selo77.github.io/categories/DevEnv/ETC/"/>
    
    
      <category term="ELKR" scheme="https://selo77.github.io/tags/ELKR/"/>
    
      <category term="로그분석" scheme="https://selo77.github.io/tags/%EB%A1%9C%EA%B7%B8%EB%B6%84%EC%84%9D/"/>
    
      <category term="Wireshark" scheme="https://selo77.github.io/tags/Wireshark/"/>
    
      <category term="Packet" scheme="https://selo77.github.io/tags/Packet/"/>
    
  </entry>
  
  <entry>
    <title>AWS Lambda를 활용한 HTTP API 만들기 01</title>
    <link href="https://selo77.github.io/2016/07/13/AWS-LAMBDA01/"/>
    <id>https://selo77.github.io/2016/07/13/AWS-LAMBDA01/</id>
    <published>2016-07-13T12:23:23.000Z</published>
    <updated>2016-07-13T12:30:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR00sVuQRAJAT_CLUVsR6CuwcdYbbPV0FlmT9gRbZdg8cF9tKL0Ng"></p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR00sVuQRAJAT_CLUVsR6CuwcdYbbPV0FlmT9gRbZdg8cF9tKL0Ng&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Relate
    
    </summary>
    
      <category term="Cloud" scheme="https://selo77.github.io/categories/Cloud/"/>
    
      <category term="AWS" scheme="https://selo77.github.io/categories/Cloud/AWS/"/>
    
    
      <category term="AWS" scheme="https://selo77.github.io/tags/AWS/"/>
    
      <category term="LAMBDA" scheme="https://selo77.github.io/tags/LAMBDA/"/>
    
      <category term="API Gateway" scheme="https://selo77.github.io/tags/API-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회</title>
    <link href="https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/"/>
    <id>https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/</id>
    <published>2016-07-10T05:10:43.000Z</published>
    <updated>2016-07-11T12:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론-왜-알고리즘-자료구조를-공부하려-하는가"><a href="#서론-왜-알고리즘-자료구조를-공부하려-하는가" class="headerlink" title="서론 - 왜 알고리즘, 자료구조를 공부하려 하는가?"></a>서론 - 왜 알고리즘, 자료구조를 공부하려 하는가?</h2><p>프로그래밍을 시작하고 거짓말 조금 보태서 하루도 빠짐없이 코딩을 해왔습니다. 그 기간이 오래 되지는 않았지만 쉬지 않고 달려온듯 합니다. 모르는 개념들을 이해하기 위해 닥치는대로 공부하고 어떻게든 해결해왔습니다. 그렇게 현재는 Python을 주 언어로 사용하는 Backend 개발자가 되었고, 현재는 주로 API 개발을 하고 있습니다. 하지만 어느 순간 부터 큰 고민이 생겼습니다. 무언가 만들기 급급한 프로그래밍을 하고 있다는 의구심이었습니다. 아래는 제가 첫 포스트에 썼던 글입니다.</p>
<blockquote>
<p>저에게 파이썬은 아름답습니다. 배우기 쉽고, 간결하며 높은 생산성을 갖고 있습니다. 그렇지만 파이썬 언어도 결국은 프로그래머의 하나의 도구에 불과합니다. <strong><em>단순히 프로그래밍을 할 수 있는 것과 좋은 프로그래밍을 하는 것은 하늘과 땅 차이입니다. 결국 프로그래밍의 수준은 언어가 아닌 프로그래머의 역량입니다.</em></strong> 결론적으로 프로그래밍 자체를 아름답게 하기 위해서는 언어에 상관없이 프로그래밍 자체를 공부해야 합니다. 알고리즘, 디자인패턴, 아키텍처, 테스트기법, 동시성, 자료구조 등의 필요한 지식을 유기적으로 이해할 수 있다면 어떤 언어를 사용하더라도 아름다운 프로그래밍을 할 수 있는 개발자가 될 것이라 생각합니다.</p>
</blockquote>
<p>지금까지 저는 단순히 프로그래밍을 하는 프로그래머였던것 같습니다. 단순히 프로그래밍을 하는 것이 나쁘다는 문제가 아니라 위에서 언급했듯 저는 아름다운 코드를 만드는 프로그래머가 되고 싶습니다. 이를 위한 첫 시작으로 알고리즘과 자료구조를 기초부터 다져나가려 합니다.</p>
<p><img src="http://book.algospot.com/static/img/cover1-small.png"></p>
<p><strong>프로그밍 대회에서배우는 알고리즘 문제해결 전략 (구종만 지음)</strong> 책을 선정해  체계적으로 학습할 계획입니다. 1000페이지가 넘는 다소 버거운 분량임에도 불구하고 이 책을 선정한 이유는 단순히 알고리즘 문제를 소개하고 풀이하는데 그치지 않고, 프로그래밍의 본질인 문제해결이라는 추상적인 개념을 단계를 나누어 체계적으로 학습할 수 있도록 구성되어 있기 때문입니다. 그럼 이제 시작해볼까요!! Let’s go!! Get it!!</p>
<p><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7058764" target="_blank" rel="external">알고리즘 문제해결전략 책소개 및 목차</a></p>
<h2 id="01-문제-해결과-프로그래밍-대회"><a href="#01-문제-해결과-프로그래밍-대회" class="headerlink" title="01 문제 해결과 프로그래밍 대회"></a>01 문제 해결과 프로그래밍 대회</h2><blockquote><p> <strong>프로그래밍은 문제 해결이다</strong><br>프로그램밍을 하기 위해서는 많은 것을 알아야 합니다. 아무 생각 없이 키보드를 두드리는 것처럼 보이는 프로그래머의 머릿속에는 자신이 사용하고 있는 프로그래밍 언어의 특성, 프로그래밍이 동작할 하드웨어와 운영체제에 관한 지식, 사용하고 있는 라이브러리들에 대한 유의 사항들이 회오리치고 있습니다. (중략) 이 와중에 가능한 한 재사용성이 높은 간결한 코드를 작성해야합니다.<br>이렇게 많은 제약조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력은 좋은 프로그래머가 되기 위해 필수적입니다. 이 책에서는 이런 능력을 문제 해결 능력이라고 부릅니다. 프로그래머가 사용하는 언어나 라이브러리, 알고리즘에 대한 지식 들이 퍼즐의 조각이라면 문제 해결 능력은 적재적소에 퍼즐 조각을 배치하고 이들을 연결해서 큰 그림을 만드는 능력이라고 할 수 있습니다.</p>
<footer><strong>5page</strong><cite>알고리즘 문제해결전략</cite></footer></blockquote>
<p><strong>‘01 문제 해결과 프로그래밍 대회’</strong> 장에서는 문제해결이 무엇인지 정의하고 좋은 프로그래밍을 하기 위해 왜 알고리즘이 필요하고 어떻게 공부해야할지 큰 방향을 제시합니다. 다음 2장 <strong>‘문제 해결 개관’</strong> 은 문제 해결 과정을 여러 단계로 나눠 보고 각 단계를 더 잘하기 위한 여러 기술들을 소개합니다. 책을 구입한지 반년만에 첫 발을 내 딛였습니다. 구종만 작가님이 입문자를 위한 커리큘럼을 제시해주셨고, 저는 그걸 따라 공부할 것입니다. 그렇기에 건너뛰는 장이 있을 수 있음을 미리 말씀드립니다. 첫번째시간은 이렇게 가볍게 마무리하고 다음편에 뵙겠습니다. 행복하세요~</p>
<blockquote>
<p>Well begun is half done</p>
</blockquote>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7058764" target="_blank" rel="external">(책) 알고리즘 문제해결전략 - 구종만</a></li>
</ul>
<p><br><br>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관</a>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;서론-왜-알고리즘-자료구조를-공부하려-하는가&quot;&gt;&lt;a href=&quot;#서론-왜-알고리즘-자료구조를-공부하려-하는가&quot; class=&quot;headerlink&quot; title=&quot;서론 - 왜 알고리즘, 자료구조를 공부하려 하는가?&quot;&gt;&lt;/a&gt;서론 - 왜 알고리
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://selo77.github.io/tags/Algorithm/"/>
    
      <category term="ProblemSolvingStrategies" scheme="https://selo77.github.io/tags/ProblemSolvingStrategies/"/>
    
  </entry>
  
  <entry>
    <title>Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 02문제 해결 개관</title>
    <link href="https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/"/>
    <id>https://selo77.github.io/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies-02Solving-Problem-Overview/</id>
    <published>2016-07-10T05:10:43.000Z</published>
    <updated>2016-07-11T12:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-도입"><a href="#2-1-도입" class="headerlink" title="2.1 도입"></a>2.1 도입</h2><p>이번장은 추상적인 프로그래밍의 과정을 좀더 체계적으로 수련하기 위한 과정을 여러 단계로 나눠 보고 각 단계를 더 잘하기 위한 전반적인 기술들을 소개합니다. 특히 구체적인 체계없이 프로그래밍을 시작하는 저와 같은 프로그래머들에게 깨닮을 줍니다. 첫번째장에서 알고리즘의 필요성과 공부를 위한 마음을 가다듬었다면 이번장에서는 앞으로 배우게될 것들에 대한 프리뷰가 되겠습니다.</p>
<h2 id="2-2-문제-해결-과정"><a href="#2-2-문제-해결-과정" class="headerlink" title="2.2 문제 해결 과정"></a>2.2 문제 해결 과정</h2><p>알고리즘은 무엇인가? 저는 이렇게 답변했습니다. “알고리즘은 어떤 특정문제를 해결하기 위한 과정과 방법의 정의” 무언가를 공부할때 개념에 대한 본인만의 정의를 갖는것은 매우 중요합니다.</p>
<blockquote>
<p>프로그래밍 대회를 위한 여섯 단계 문제 해결 알고리즘</p>
<ol>
<li>문제를 읽고 이해한다.</li>
<li>문제를 익숙한 용어로 재정의한다.</li>
<li>어떻게 해결할지 계획을 세운다.</li>
<li>계획을 검증한다.</li>
<li>프로그램으로 구현한다.</li>
<li>어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.</li>
</ol>
</blockquote>
<ol>
<li><strong>문제를 읽고 이해합니다.</strong></li>
<li><strong>재정의와 추상화.</strong> 문제를 익숙한 용어로 재정의 하며 추상화 과정을 통해 프로그래밍이 나아갈 방향을 결정합니다. 이 부분에서 추상화를 좀 더 구체적으로 정의하자면, 객체지향에서 현실세계의 존재를 클래스화 하는 과정과 비슷하다고 이해 하시면됩니다. 문제를 우리가 이해하기 쉬운 수학이나 전산 개념으로 표현하는 과정이라 생각합니다. 추상화 과정은 좋은 프로그래머가 되기 위한 필수적인 조건이며 이 단계를 넘지 못한다면 좋은 프로그래머가 되지 못할 것이라 생각됩니다.</li>
<li><strong>계획 세우기.</strong> 이 단계는 문제해결의 과장 중요한 과정이며 사용할 알고리즘과 자료구조를 선택합니다.</li>
<li><strong>계획 검증하기.</strong> 제가 주로 간과하는 부분입니다. 이 단계에서는 시간복잡도와 공간복잡도의 문제를 고려합니다.</li>
<li><strong>계획 수행하기.</strong></li>
<li><strong>회고 하기.</strong> 이 단계는 제가 최근 가장 중요하게 여기는 부분입니다. 블로그에 굳이 공부한 내용을 포스팅 하는이유도 다른 사람에게 보여주기 보다는 회고의 과정을 통해 지식의 견고함을 갖추기 위함입니다. 문제 해결에서 효과적 회고 수행은 문제를 풀 때마다 코드와 함께 본인만의 로그를 남기는 것입니다. 물론 문제를 맞추지 못한 경우에도 해당하며 부족한 부분을 감지하고, 다른 사람의 코드를 보면서 새로운 통찰을 얻곤합니다.</li>
</ol>
<blockquote>
<p><strong>잠시만요!!</strong><br><a href="www.codewars.com">코드전쟁</a> - 사이트 이름처럼 쉬운 문제부터 고난이도 문제까지 닥치는대로 풀어 볼 수  있는 기회를 제공하며, 무엇보다 다른 사람의 작성된 답안을 보면서 코드 작성의 수준을 향상시킬 수 있습니다.</p>
</blockquote>
<h2 id="2-3-문제-해결-전략"><a href="#2-3-문제-해결-전략" class="headerlink" title="2.3 문제 해결 전략"></a>2.3 문제 해결 전략</h2><p>프로그래머에게 문제를 이해하는 직관의 수준은 곧 그 프로그래머의 수준이고 생각합니다. 이렇게 중요한 직관은 하루아침에 만들어 질 수 없으며, 체계적인 학습과 경험 없이는 향상시킬수 없다 생각합니다.</p>
<blockquote>
<h3 id="체계적인-접근을-위한-질문들"><a href="#체계적인-접근을-위한-질문들" class="headerlink" title="체계적인 접근을 위한 질문들"></a>체계적인 접근을 위한 질문들</h3><ul>
<li>비슷한 문제를 풀어본 적이 있던가?</li>
<li>단순한 방법에서 시작할 수 있을까?</li>
<li>내가 문제를 푸는 과정을 수식화할 수 있을까?</li>
<li>문제를 단순화할 수 없을까?</li>
<li>그림으로 그려볼 수 있을까?</li>
<li>문제를 분해할 수 있을까?</li>
<li>뒤에서부터 생각해서 문제를 풀 수 있을까?</li>
<li>순서를 강제할 수 있을까?</li>
<li>특정 형태의 답만을 고려할 수 있을까?</li>
</ul>
</blockquote>
<h2 id="중간-정리"><a href="#중간-정리" class="headerlink" title="중간 정리"></a>중간 정리</h2><p>1장과 2장을 통해 문제 해결 능력을 정의 하고 향상시키기 위해 필요한 과정들을 집어보았습니다. 그럼 다음 포스팅에는 낮은 수준?의 알고리즘을 문제를 풀어보면서 위 에서 학습한 과정과 전략들을 적용해 보겠습니다. 문제 ==&gt; <a href="https://algospot.com/judge/problem/read/FESTIVAL#" target="_blank" rel="external">https://algospot.com/judge/problem/read/FESTIVAL#</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://book.naver.com/bookdb/book_detail.nhn?bid=7058764" target="_blank" rel="external">(책) 알고리즘 문제해결전략 - 구종만</a></li>
</ul>
<p><br><br>잘못된 부분에 대한 지적은 언제든지 감사히 받겠습니다.<br><a href="rochan87@gmail.com">rochan87@gmail.com</a></p>
<h2 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h2><a href="/2016/07/10/Algorithm-Algorithmic-Problem-Solving-Strategies/" title="Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회">Algorithmic Problem Solving Strategies(알고리즘 문제해결전략) - 01문제해결과 프로그래밍 대회</a>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2-1-도입&quot;&gt;&lt;a href=&quot;#2-1-도입&quot; class=&quot;headerlink&quot; title=&quot;2.1 도입&quot;&gt;&lt;/a&gt;2.1 도입&lt;/h2&gt;&lt;p&gt;이번장은 추상적인 프로그래밍의 과정을 좀더 체계적으로 수련하기 위한 과정을 여러 단계로 나눠 보고
    
    </summary>
    
      <category term="Base" scheme="https://selo77.github.io/categories/Base/"/>
    
      <category term="Algorithm" scheme="https://selo77.github.io/categories/Base/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://selo77.github.io/tags/Algorithm/"/>
    
      <category term="ProblemSolvingStrategies" scheme="https://selo77.github.io/tags/ProblemSolvingStrategies/"/>
    
  </entry>
  
  <entry>
    <title>Python- yield, generator, coroutine</title>
    <link href="https://selo77.github.io/2016/07/05/Python-Asyncio/"/>
    <id>https://selo77.github.io/2016/07/05/Python-Asyncio/</id>
    <published>2016-07-05T11:16:31.000Z</published>
    <updated>2016-07-10T04:58:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AsyncIO"><a href="#AsyncIO" class="headerlink" title="AsyncIO ?"></a>AsyncIO ?</h2><p>아래 그림은 Python3.4 부터 적용된 asyncIO 라는 강력한 비동기 모듈의 프로세스를 간략하게 설명한 그림입니다. 보자마자 머리가 지끈 지끈 아파오기 시작하시져?</p>
<p><img src="https://docs.python.org/3/_images/tulip_coro.png"></p>
<p>비동기, 병령처리, 동시성 너무나 자주 듣는 용어들이지만 깔끔하게 머릿속에 정리가 되지않습니다. 매일 같이 아래와 같은 코딩을 비동기 기반 개발을 함에도 불구하고 반에 반 밖에 이해를 못하고 코딩을 하는것 같습니다.ㅠㅠ 그래서 이번 기회에 포스팅을 통해 AsyncIO 비동기 모듈을 완벽 정복해보려 합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> module_dao, module_email</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">an_asyn_fnc</span><span class="params">()</span>:</span></span><br><span class="line">  item = <span class="keyword">yield</span> <span class="keyword">from</span> another_asynfnc()</span><br><span class="line">  asyncio.<span class="keyword">async</span>(module_email(item.email))</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_asynfnc</span><span class="params">()</span>:</span></span><br><span class="line">  query = <span class="string">"""</span><br><span class="line">  SELECT * FROM users WHERE userID = 'SELO'</span><br><span class="line">  """</span></span><br><span class="line">  dt_user = <span class="keyword">yield</span> <span class="keyword">from</span> module_dao(query)</span><br><span class="line">  <span class="keyword">if</span> dt_user.get(<span class="string">'succeed'</span>, <span class="keyword">None</span>):</span><br><span class="line">    <span class="keyword">return</span> dt_user[<span class="string">'item'</span>]</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception</span><br></pre></td></tr></table></figure>
<p>(위 코딩은 너무 깊게 생각할 가치가 없습니다……. 하지만 한번 눈으로 보시면 아래 개념들을 이해하는데 조금은 도움이 될듯합니다.)</p>
<h2 id="yield-generator-coroutine"><a href="#yield-generator-coroutine" class="headerlink" title="yield, generator, coroutine"></a>yield, generator, coroutine</h2><p>AsyncIO 를 이해하기 위해서 사전에 알고가야 할 개념들이 존재합니다. 바로 오늘 같이 공부해볼 yield 키워드, generator 객체, coroutine 개념입니다. 먼저 yield 키워드와 generator 부터 살펴보겠습니다.</p>
<p><strong>return 처럼 yield는 값을 반환한다. 하지만 yield는 리턴 값을 비롯한 Context(환경) 포함한 제너레이터라는 객체를 반환하는데 이 제네레이터 객체는 iterable(순환가능) 합니다.</strong> 말이 상당히 야리꾸리 합니다. 처음에는 이해가 안되는게 당연합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  print(i, end= <span class="string">","</span>) <span class="comment"># 0,1,2,3,4,</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_range</span><span class="params">(end)</span>:</span></span><br><span class="line">  i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; end:</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">result = custom_range(<span class="number">5</span>)</span><br><span class="line">print(result) <span class="comment"># &lt;generator object custom_range at 0x1017c5a98&gt;</span></span><br></pre></td></tr></table></figure>
<p>위 custom_range() 함수는 내장함수인 range() 함수를 제너레이터를 이용해 구현한 예입니다.<br>위와 같이 구현된 함수를 코루틴 함수라 합니다. 코루틴? 제너레이터? 여기서는 하나만 기억하고 넘어갑시다. yield가 선언된 함수는 yield를 만나는 순간 제너레이터라는 객체를 반환한다!! 그러면 왜 제너레이터는 순환가능한 것인가? 왜 순환 가능하여야만 하는가? 아래 코드를 보면서 궁금증을 풀어봅시다.</p>
<h3 id="generator는-순환-가능-왜"><a href="#generator는-순환-가능-왜" class="headerlink" title="generator는 순환 가능!! 왜?"></a>generator는 순환 가능!! 왜?</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">  print(i, end=<span class="string">','</span>) <span class="comment"># 0,1,2,3,4,</span></span><br><span class="line">print()</span><br><span class="line">print(list(custom_range(<span class="number">5</span>))) <span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line">print([i <span class="keyword">for</span> i <span class="keyword">in</span> custom_range(<span class="number">5</span>)]) <span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">generator = custom_range(<span class="number">2</span>)</span><br><span class="line">print(next(generator)) <span class="comment"># 0</span></span><br><span class="line">print(next(generator)) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 아래코드는 리스트의 아웃오브인덱스 예외와 유사하다. 더이상 진입점이 없으므로 예외를 발생시킨다.</span></span><br><span class="line"><span class="comment"># print(next(generator)) # raise Exception StopIteration</span></span><br></pre></td></tr></table></figure>
<p>위 generator 변수에 대입된 custom_range(2) 함수는 yield 키워드에서 값을 반환하고, 다음 next()에 의해 호출될 때까지 해당 라인을 진입점으로 기억해둡니다. 이러한 진입점이 여러 개 인 함수를 코루틴(coroutine) 이라하며, 기존에 우리가 주로 사용하는 코드를 순서대로 실행하다가 return 코드를 만나고 최종 값을 리턴하면서 context를 잃는 방식을 서브루틴(subroutine)이라고 합니다. 결론은 이미 첫째줄에 말씀드렸는데요. <strong><em>“yield를 만나는 순간 Context(환경)를 포함한 제너레이터라는 객체를 반환.” 결국 제너레이터라는 객체는 코루틴이라는 함수가 진입점을 여러 곳 갖고 있기때문에 호출되는 순서에 따라 Context(환경)이 달라지게 됩니다. 이로 인하여 iterable(순환가능) 할 수 밖에 없는 숙명을 띠게 됩니다.</em></strong></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://b.ssut.me/58" target="_blank" rel="external">Python 3, asyncio와 놀아보기</a><br>rochan87@gmail.com 필자의 머릿속.</p>
<p><strong>잘못된 정보에 대한 지적은 언제든지 감사히 받겠습니다.</strong></p>
<!-- ### Related Posts -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AsyncIO&quot;&gt;&lt;a href=&quot;#AsyncIO&quot; class=&quot;headerlink&quot; title=&quot;AsyncIO ?&quot;&gt;&lt;/a&gt;AsyncIO ?&lt;/h2&gt;&lt;p&gt;아래 그림은 Python3.4 부터 적용된 asyncIO 라는 강력한 비동기 모듈의
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
      <category term="asyncio" scheme="https://selo77.github.io/tags/asyncio/"/>
    
      <category term="yield" scheme="https://selo77.github.io/tags/yield/"/>
    
      <category term="generator" scheme="https://selo77.github.io/tags/generator/"/>
    
      <category term="coroutine" scheme="https://selo77.github.io/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>나는프로그래머다 - 나프다컨 복기</title>
    <link href="https://selo77.github.io/2016/06/25/iamprogrammer-conference-review/"/>
    <id>https://selo77.github.io/2016/06/25/iamprogrammer-conference-review/</id>
    <published>2016-06-25T08:26:51.000Z</published>
    <updated>2016-06-25T10:59:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://iamprogrammersite.files.wordpress.com/2016/06/2016meetup.png?w=840"></p>
<h1 id="나는프로그래머다-참여-후기-1부"><a href="#나는프로그래머다-참여-후기-1부" class="headerlink" title="나는프로그래머다 참여 후기 1부"></a>나는프로그래머다 참여 후기 1부</h1><p>제목은 참여 후기지만 실상은 두서없는 주저리가 될 것이다.</p>
<h2 id="복기"><a href="#복기" class="headerlink" title="복기"></a>복기</h2><p>나는 프로그래머다 일명 나프다 개발자 컨퍼런스에 참여했다. 컨퍼런스에서 느낀점을 두서 없이 복기 해볼까한다. 자꾸 복기라는 단어를 선택해서 사용하는 것을 이 글을 읽는 분이라면 느꼈을 것이다. 그 이유는 컨퍼런스에서 데니스님이 언급하신 내용 때문이다. 복기란 바둑에서 주로 쓰이는 단어로서 대국이 끝난 후 상대방과 두었던 수에 대해 복습을 의미한다. 나는 학습하는 과정에서 복기를 중요시 여기지 않으며 살아왔다. 내 자신에 대한 자만인지 뭔지는 모르겠지만 한마디로 허접하게 살아왔다.</p>
<p>바둑을 잘 모르는 나를 포함한 많은 사람도 이세돌의 이름 한번쯤은 들어 봤을 것이다. 이세돌은 어떻게 세계최고의 바둑기사가 되었을까? 타고난 천재적 재능? 금수저? 좋은환경? 물론 위에 이유들도 무시할 수는 없을 것이다. 하지만 그는 대국 후 철저한 복기를 하기로 유명하다. 알파고와 대국이 끝난 뒤에도 동료 기사들과 밤새 복기를 했다고 한다. 결론 적으로 알파고가 이겼지만 3연패 뒤 이세돌은 3연승 보다 값진 1승을 이루어 내었다. 그의 1승은 결코 우연이 아닐 것이다. 나는 그의 1승의 가장 큰 이유는 연속된 패배에도 멈추지 않았던 복기를 뽑고 싶다. 복기를 통해 알파고의 약점을 집요하게 파악했고, 자신의 부족함을 보강해 나갔을 것이다.</p>
<p>뛰어난 사람은 생각보다 많다. 특히 나프다 컨퍼런스와 같음 모임에 참여하면 한없이 부족함을 깨닫게 된다. 사실 나같은 경우는 자만할 실력도 없긴하다. 현재는 그렇다. 말하고 싶은 요점은 하나다. <strong><em>뛰어난 사람은 많지만 인정받는 사람은 많지 않다는 점이다. 인정받는 사람 사람이 되기 위해서는 자기 세상에 빠져서는 안된다. 주변을 볼줄 알아야 하고 그렇기 위해서는 항상 깨어있어야한다. 이런 점에 복기는 최고의 방법이 될 수 있다.</em></strong></p>
<p>나는 뛰어난 사람이 되고 싶다. 하지만 인정받지 못하면서 뛰어난 사람이 되고 싶지는 않다. 내가 삶을 살아가는 이유는 내가 사랑하는 사람들에게 인정받고, 내 자신 스스로에게도 인정받고 싶기때문이다.</p>
<p>임백준 작가님께서 라이브 코딩을 선사한 대마고학생들의 뛰어난 재능에도 불구하고 걱정을 표현했던 부분이 이와 같은 맥락이 아닐까 생각한다.</p>
<h2 id="자유와-행복"><a href="#자유와-행복" class="headerlink" title="자유와 행복"></a>자유와 행복</h2><p>이번 주저리는 3번째 세션을 중심으로 이야기를 진행해보겠다. 3번째 세션의 트랙1은 염산악님과 정개발님의 ‘코딩인터뷰 준비 티끌 가이드’였고, 트랙2는 박현천님의 ‘자유와 일을 사랑하는 개발자, 디지털 노마드를 말하다.’ 였다. 나는 트랙2의 박현천님의 트랙을 들었다. 그 이유는 단순하다. 자유라는 주제를 다루고 있었기 때문이다. 왜 개발자로서 삶을 선택했가? 먹고 살기 위해서? 개발이 좋아서? 그냥? 여기에 정답은 없지만 모법답안은 개발이 좋아서 일것이다. 개발이 좋아서 라면 왜 개발이 좋은가? 이 부분을 답하는데 고민이 생긴다면 한번쯤 생각해 보자.</p>
<p>내가 개발을 하는 가장 큰 이유는 자유다. 개발자란 직업은 다른 직업에 비해 자유롭다. 물론 이에 대해 반대되는 의견도 많을리라 생각한다. 하지만 개발자란 단어 그대로 의미를 생각해보면 무언가를 개발하는 직업은 다른 직업에 비해 자유도가 매우 중요하다 생각한다. 나의 부족한 식견때문인지 머릿속에서 맴도는 생각이 잘 정리가 되지 않지만ㅠㅠ 개발자에게 자유는 매우 중요하다. 구체적인 설명이 힘듬으로 예를 들어 설명해보겠다. 최고의 회사 구글을 살펴보자. 그들의 회사는 정해진 규율안에 매우 자유롭다. 강아지와 함께 출근을 하거나 필요한 경우에 원격근무를 하고, 자유로운 복장으로 출근한다. 이외에도 수도 없이 많다. 그리고 그들은 지구 최고의 회사다. 지금으로서는 그렇다.</p>
<p>나의 꿈은 적당히 돈 있는 한량이다. 한량 == 백수. 이유는 간단하다 나는 내가 하고싶은 일을 할 수 있는 자유가 있을때 행복하다. 한량은 자유롭다. 이렇게 내가 쓰고 싶은 말을 하고, 생각하고, 하고 싶은일을 하고, 사랑하는 사람과 함께하며, 사람들에게 인사이트를 주고싶다. 죽을때까지 이꿈을 이룰수 있으리라는 보장은 없지만 이런 미래에 대한 목표가 나를 이끄는 원동력이다.</p>
<p>주저리를 정리해보자면 박현천님의 트랙에 생각보다 적은 사람이 와서 아쉬웠다. 코딩인터뷰 물론 개발자에게 매우 중요한 주제다. 구글의 염산악님과 정개발님께서 발표를 해주신다니 나 같아도 자유라는 단어가 포함된 트랙이 아니였다면 그 트랙에 참여했을 것이다. <strong><em>코딩인터뷰를 준비하고 좋은 회사에 들어가기 전에 본인이 왜 개발을 이렇게 열정적으로 하고 있으며, 개발을 할때 진정 행복한지 한번 쯤 고민을 해보는 시간이 필요하다 생각한다. 특히 “나는 왜 개발하는가?” 질문에 답변이 힘들었다면 말이다.</em></strong></p>
<h2 id="데니스"><a href="#데니스" class="headerlink" title="데니스"></a>데니스</h2><p>데니스님은 귀엽다. 진심이다. 참고로 필자는 약혼자가 있다. 오해금물.</p>
<p>나는 데니스 같은 분을 좋아한다. 나는 데니스님을 보면 김구라가 떠오른다. 나는 김구라도 좋아한다. 데니스는 김구라와 비슷하다. 이 문장은 논리적인가? 삼단추론논법인가 대기업 취업준비를 할때 이런 문장이 논리적인지 판단하는 문제를 풀곤했다. 아무튼 데니스를 김구라에 비유하는 이유는 두분다 독설가이다. 본인이 아니다 하는 생각에 대해서는 열정적으로 비판한다. 비판가는 욕먹기 십상이다. 특히 흑백논리가 편협한 대한민국에서는 그렇다. 임작가님과 같이 노련한 비판가들은 은유적으로 비판한다. 야생에서 오래 서식한 데니스님은 야생마다(발음조심) 우선 아니다 싶으면 아니다 말한다. 컨퍼런스 중에서도 이런면이 여김없이 들어났다. 가끔 마이크를 돌진하시더라.. 가끔은 안쓰럽기도 하다. 나프다 방속에서 어떤 이야기를 함에 있어 임작가님과 데니스님의 맥락이 같음에도 불구하고 데니스님만 욕을 먹을때가 있는 것같다.ㅠㅠ 이래서 표현방식이 중요하다는 것인가?! 하지만 야생마에게 이런 것을 요구하는 오른방법이 아니다. 야생마는 야생마이기에 멋이 있는 것이다.</p>
<p><strong><em>내가 생각하는 대한민국에는 더 많은 야생마가 존재해야한다. 더욱 비판하고, 잘못됨을 일깨워 줘야한다. 데니스님이 꼭 오른말은 한다는 것이 아니다. 다양한 생각이 교류 될 수 있는 환경이 만들어져야 한다는 것이다. 그렇기 위해서는 야생마를 길들여 경주마로 만들려고 하기보다는 야생마가 더 뛰어 다닐 수 있는 환경이 만들어 져야하지 않을까 생각해본다.</em></strong></p>
<p><strong><em>결론 데니스 = 야생마(발음조심)</em></strong></p>
<hr>
<p>항상 머릿속에만 있던 생각을 글로 이렇게 표현 하려니 기운이 쏙쏚 빠진다ㅠㅠ 그래서 너무 배가 고프다. 친구가 왔다. 밥먹으러 가야한다. 그러므로 후기 2부는 다음에 작성해야지~~ 읽어 주시는 분이 있을지 모르지만 읽어 주셨다면 감사합니다(꾸벅). 아 그리고 어떤 의견이든 환영합니다.</p>
<p>마지막으로 우리는!!! 프로그래머닷!!!</p>
<p><img src="https://iamprogrammersite.files.wordpress.com/2016/06/e18482e185a1e18491e185b3e18483e185a12e18480e185afe186abe18491e185ade1848ce185b5.jpeg?w=840"></p>
<p>아참 한빛소프트 부스에서 나프다 2권도 구입!!!<br>사실 대살개문이 더 끌렸지만 좋은 방송을 듣게 해주는 고마움의 표현. 나프다 구입 결정!!!</p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://iamprogrammersite.files.wordpress.com/2016/06/2016meetup.png?w=840&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;나는프로그래머다-참여-후기-1부&quot;&gt;&lt;a href=&quot;#나는프로그래머다-
    
    </summary>
    
      <category term="Memorandum" scheme="https://selo77.github.io/categories/Memorandum/"/>
    
    
      <category term="나는프로그래머다" scheme="https://selo77.github.io/tags/%EB%82%98%EB%8A%94%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EB%8B%A4/"/>
    
      <category term="나프다" scheme="https://selo77.github.io/tags/%EB%82%98%ED%94%84%EB%8B%A4/"/>
    
      <category term="개발자모임" scheme="https://selo77.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%AA%A8%EC%9E%84/"/>
    
      <category term="iamprogrammer" scheme="https://selo77.github.io/tags/iamprogrammer/"/>
    
  </entry>
  
  <entry>
    <title>Git 개념 및 유용한 사이트</title>
    <link href="https://selo77.github.io/2016/06/24/git-definition-usefulsite/"/>
    <id>https://selo77.github.io/2016/06/24/git-definition-usefulsite/</id>
    <published>2016-06-24T12:10:09.000Z</published>
    <updated>2016-06-25T10:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>안녕하세요. 새로입니다. 오늘은 오픈소스 저장소로 유명한 Git에 대해서 알아보는 시간이 되겠습니다. 이번 토픽을 Git으로 선정하게 된 이유는, 몇일전 회사에서 신규서비스 오픈 중 개고생을 했기때문인데요. 머지와 리베이스 그 지옥에서 벗어나기 위해 발버둥 첬던 밤샘작업. 그 뼈아픈 경험때문에 이번 기회에 git의 필요한 부분을 정리하기로 마음먹었습니다. 포스팅 주제와 관련된 필자의 수준은 다음과 같습니다.(2016-06-06) <br><br><strong>능력 평가는 지극히 주관적임을 먼저 밝힙니다.</strong></p>
<ul>
<li>SVN(형상관리툴) 사용경험 없음.  </li>
<li>참여한 모든 프로젝트에서 Git을 사용했었음 동료에게 피해주지 않을 만큼 정도의 Git사용 실력(가장 중요한 부분!!!)</li>
</ul>
<p>Ps. 누군가 싼 똥은 다른 사람에게 전파된다…..</p>
<h2 id="Git-개념"><a href="#Git-개념" class="headerlink" title="Git 개념"></a>Git 개념</h2><p>먼저 시작하기전에 Git의 기본 개념에 대해 알고 넘어가야겠G요. Git이란 버전관리 시스템으로 쉽게 이해하면 소스코드의 백업공간입니다. 보고서나 어떤 문서를 작성할때 원본파일을 복사하여 복사본을 만들고 수정하셨던 경험이 있을 것입니다. 하지만 파일을 편집할 때 마다 복사본을 만드는 것은 우리모두의 치명적 약점. 언제나 실수 할 수 있다는 점을 생각했을 때 좋지 못한 방법입니다. 그리고 더욱 치명적인 것은 그 작업을 여러명이 진행할 때 실수 확률은 훨씬 더 클것입니다. 언제나 그랬듯이 우리는 우리의 약점을 보완하기 위한 도구를 만들게 됩니다. 그것이 바로 Git과 같은 버전관리 시스템입니다.</p>
<h2 id="Git에-대한-수다"><a href="#Git에-대한-수다" class="headerlink" title="Git에 대한 수다"></a>Git에 대한 수다</h2><p>Git의 사용법은 이 포스팅에서는 따로 하지 않겠습니다. 이유는 체계적으로 정리된 튜토리얼 사이트가 많이 존재하기 때문입니다. 그래서 저는 Git을 사용하면서 느꼈던 점과 중요 포인트를 정리할 예정이며, Git을 공부하실때 제가 언급한 포인트를 생각하면서 공부하시면 좋을것 같습니다.<br>(이번 Git 포스팅은 회사 서비스 오픈과 겹쳐 성의가 많이 떨어짐을 양해 부탁합니다(꾸벅)……….. 우쒸 보기 싫음 보지마 퉤……)</p>
<p>팀원 모두가 잘쓰면 정말 좋은 Git, 아니라면 I’m sure that your team will be in HELL soon. Git을 처음 사용하면 생각보다 복잡한 개념과 사용법에 고전하게 됩니다. 그렇다고 하던 개발을 멈추고, Git을 공부하기란 쉽지않습니다. 결국 개발은 개발대로 진행하고, remote repository에 Push나 Merge를 할때 동료직원중 Git 고수를 소환하여 문제를 해결합니다. 여기까지는 별 문제가 없습니다. 하지만 언제나 함께였던 Git고수 동료가 없을때 문제가 발생합니다.</p>
<p>평소 하던대로 커밋을 하고 풀을 받고, 푸쉬를 하려합니다. 하지만 오랜만에 머지를 해서 그런지 충돌이 난 것같습니다. 충돌때문에 푸쉬가 되지않습니다. 여기서 부터 당황하기 시작합니다. 침착하게 소스코드를 확인합니다. 하지만 방금전까지 멀쩡하던 코드에 뒤죽박죽 빨간줄이 생기고, 에러 천국이 되어버렸습니다. Git을 욕하기 시작합니다. “이 썅개뭐같은것 이딴거 왜쓰는거야?!!”. 욕하는 것도 잠시. 개발한 소스를 갱신하지 않으면 다른 동료 작업에 지장이 있기에 최대한 빨리 푸쉬를 해줘야합니다. 에라 모르겠다. 기존에 백업해둔 로컬 파일을 덮어쓰고 푸쉬합니다. 분명 자기자신만 사용하던 하위 브랜치기에 문제가 없으리라 생각합니다. 참고로 로컬에서는 정상적으로 잘 동작하던 소스였습니다.</p>
<p>다음날 오전…. 해맑게 웃으며 동료들과 스크럼 미팅을 진행합니다. 어제 개발 반영한 것에 대해 다음 작업을 진행할 동료에게 내용을 전달합니다. 5분뒤 누군가의 비명소리가 들려옵니다. “만어ㅣㅁ나어미나엄니ㅏ엄니ㅏ어마ㅣㄴ어ㅣ 내 소스 어디갔어 꺄오꺄오 ㅅㅍㅅㅍ!!!!!” 본능적으로 느낍니다. ‘나구나’ Git을 사용하면서 Overwrite을 하는것은 절대적으로 피해야합니다. <strong><em>충돌은 반드시 소스 내에서 해결하여야 합니다.</em></strong></p>
<h2 id="Git-가지를-치자"><a href="#Git-가지를-치자" class="headerlink" title="Git 가지를 치자!!!"></a>Git 가지를 치자!!!</h2><p>Git을 사용하다보면 어마무지한 뻘짓들을 하게 됩니다. 그러면서 얻은 교훈은 가지를 치자 가지치는데 돈 안들고 가지를 잘 칠 수록 행복해지리라~~!! 제가 사용하는 깃방식을 예를 들면 뿌리 (master)를 토대로 기둥(develop)으로 파생되고, 중심가지(서비스 카테고리. 지금 하는 서비스 같은 경우는 항공, 호텔, 보험 등)들이 자라납니다. 여기까지는 아주 훌륭합니다. 그러나 각 파트에서 개발하는 기능들은 가지를 치지 않는 경우가 발생합니다. 여기서 문제가 발생합니다. 가지를 치지 않은상태에서 진행중인 개발사항을 커밋을 하고 푸쉬를 했다고 칩시다. 그런데 다른 팀원의 기능개발이 끝나 develop 브랜치와 머지를 진행한다 합니다. ‘헐…. 나는 아직 안되는데……. 어쩌지어쩌지 !!! 으악.’ 브랜치만 잘 땃어도ㅠㅠ. 물론 해결방법은 있습니다. 하지만 쓸데없이 추가되는 비용을 발생시킬 필요는 없겠죠~ <strong><em>Git은 가지치기 위해 존재한다. 고로 가지를 치라!!</em></strong></p>
<h2 id="Git-고수가-되고-싶나"><a href="#Git-고수가-되고-싶나" class="headerlink" title="Git 고수가 되고 싶나?"></a>Git 고수가 되고 싶나?</h2><p>아래 reference만 진행하셔도 이미 당신은 깃 고수. 지금 바로시작하세요. 사실 이번 포스팅 Git은 작성하는 동안 흥미가 떨어져서 ㅠㅠ 주저리가 많았네요. 양해부탁드립니다…..(쪼쪼)</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="http://learnbranch.urigit.com/" target="_blank" rel="external">Git 브랜치 배우기</a><br>Git으로 협업을 진행할때 가장 중요한 개념인 branch에 대하여 튜토리얼을 통해 학습 할 수 있는 사이트입니다. 제가 PM이라면 신입사원에게 이 사이트의 튜토리얼을 모두 완수하라는 특명을 내리겠습니다!!</p>
</li>
<li><p><a href="https://rogerdudler.github.io/git-guide/index.ko.html" target="_blank" rel="external">git - 간편안내서</a><br>Git의 주요 명령어들이 어떤 상황에서 사용되어야 하는지 쉽게 이해할 수 있는 사이트입니다. 기본적인 git 사용법을 알고 있을때 전체적으로 훓어보기 좋습니다.</p>
</li>
<li><p><a href="http://backlogtool.com/git-guide/kr/" target="_blank" rel="external">누구나 쉽게 이해할 수 있는 Git 입문</a><br>이 사이트의 내용을 모두 이해하셨다면 나는 이미 Git 도사!!! Git의 전반적인 내용을 다루고 있습니다. 버전관리 시스템을 처음 접하시는 분 부터 이미 Git을 사용하시는 분까지 적합한 사이트입니다.</p>
</li>
</ul>
<p>아래 코드는 에러코드입니다. 신경쓰이겠지만 신경쓰지마세요.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Git</span><span class="params">(version_control_system)</span>:</span></span><br><span class="line"></span><br><span class="line">    local = &#123;</span><br><span class="line">        <span class="string">"master"</span> : source</span><br><span class="line">        <span class="string">"develop"</span> : source0</span><br><span class="line">        <span class="string">"feature"</span> : &#123;</span><br><span class="line">            <span class="string">"new_service"</span> : source1_0,</span><br><span class="line">            <span class="string">"new_feature"</span> : source2,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remotes.origin = &#123;</span><br><span class="line">        <span class="string">"master"</span> : source</span><br><span class="line">        <span class="string">"develop"</span> : source0</span><br><span class="line">        <span class="string">"feature"</span> : &#123;</span><br><span class="line">            <span class="string">"new_service"</span> : source1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkout</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rebase</span><span class="params">(self)</span>:</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;안녕하세요. 새로입니다. 오늘은 오픈소스 저장소로 유명한 Git에 대해서 알아보는 시간이 되겠습니다. 이번 토픽을 Git으로 
    
    </summary>
    
      <category term="DevEnv" scheme="https://selo77.github.io/categories/DevEnv/"/>
    
      <category term="Git" scheme="https://selo77.github.io/categories/DevEnv/Git/"/>
    
    
      <category term="DevOps" scheme="https://selo77.github.io/tags/DevOps/"/>
    
      <category term="GitHub" scheme="https://selo77.github.io/tags/GitHub/"/>
    
      <category term="Git" scheme="https://selo77.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL 개념 및 종류</title>
    <link href="https://selo77.github.io/2016/06/24/nosql-definition-basic/"/>
    <id>https://selo77.github.io/2016/06/24/nosql-definition-basic/</id>
    <published>2016-06-24T03:01:13.000Z</published>
    <updated>2016-06-24T11:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc orderedList:0 -->
<ul>
<li><a href="#nosql-그리고-mongodb-입문">NoSQL 그리고 MongoDB 입문</a></li>
<li><a href="#nosql-개념과-특징">NoSQL 개념과 특징</a></li>
<li><a href="#nosql-탄생배경">NoSQL 탄생배경</a></li>
<li><a href="#nosql-분류">NoSQL 분류</a></li>
<li><a href="#언제-어떤-nosql을-사용해야-하는가">언제 어떤 NoSQL을 사용해야 하는가?</a></li>
<li><a href="#결론">결론</a></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#related-posts">Related Posts</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2 id="NoSQL-그리고-MongoDB-입문"><a href="#NoSQL-그리고-MongoDB-입문" class="headerlink" title="NoSQL 그리고 MongoDB 입문"></a>NoSQL 그리고 MongoDB 입문</h2><p>이번 Side Project의 기술 스택으로 Meteor를 채택 진행하게되었고, 나는 Data Modeling을 맡았다. 그러나 RDBMS만 사용해본 나에게 모든 것은 새롭게 다가 왔고, Mean Stack이나 Meteor Tutorial 정도만 진행한 미천한 실력으로는 어려움을 느꼈다. 그렇게 프로젝트의 성공을 위해 NoSQL 공부를 시작한다.</p>
<p>이 글의 작정자의 수준은 아래와 같습니다.</p>
<ul>
<li>RDBMS 중급. MySQL, ORACLE 사용 경험</li>
<li>RDBMS data Modeling 초급</li>
<li>Redis 초급</li>
<li>NoSQL 초급</li>
</ul>
<h2 id="NoSQL-개념과-특징"><a href="#NoSQL-개념과-특징" class="headerlink" title="NoSQL 개념과 특징"></a>NoSQL 개념과 특징</h2><p>NoSQL : Non-Relational Operational Database SQL. 또는 Not only SQL<br>마틴 파울러의 [NoSQL: 빅데이터 세상으로 떠나는 간결한 안내서]에서 NoSQL은 아래의 조건을 만족하는 데이터라 정의했다.</p>
<ol>
<li>대용량 웹 서비스를 위하여 만들어진 데이터 저장소</li>
<li>관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화된 저장소</li>
<li>스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소</li>
</ol>
<p>NoSQL을 잘못 이해하면 스키마가 없는 DataModel 이라 이해할 수 있는데 그렇지 않다는 점을 집고 넘어가자. NoSQL은 각 시스템 마다 고유한 특징을 가진다. 하지만 일반적인 특징을 정의하고 넘어가자면, <strong><em>읽기 작업보다 쓰기 작업이 더 빠르며, 일반적으로 RDBMS에 비하여 쓰기와 읽기 성능이 월등히 빠르다. 그러나 NoSQL은 제대로 알고 쓰지 못하면 성능 저하를 불러오고, 문제를 발생시킨다.</em></strong></p>
<p>필자가 참여한 프로젝트에서는 검색속도 개선을 위해 Redis를 사용하는데 서버가 죽는 경우 Redis를 갱신시키는데 많은 시간을 소모하여, 복구 작업이 몇배는 더 걸린 경험이 있다.</p>
<h2 id="NoSQL-탄생배경"><a href="#NoSQL-탄생배경" class="headerlink" title="NoSQL 탄생배경"></a>NoSQL 탄생배경</h2><p>NoSQL이 뭐시고 저시고 공부를 하다 문득 한가지 의문이 생겼다. RDBMS라는 확고한 Database 시스템이 존재하는데!!!! 왜???? 기존의 패러다임과는 너무나도 상반된 NoSQL 시스템이 나타난것인가?!!!</p>
<p>빅데이터 세상을 맞이함에 있어 구글과 같은 대규모 서비스 업체들은 관계형 데이터베이스 만으로 트래픽을 감당하기 어려워젔고, 이를 해결 하기 위한 결과로 NoSQL을 탄생시켰다. NoSQL은 분산 환경에서 대용량의 데이터를 빠르게 처리하기 위해서 단점을 가진채 개발되었다.</p>
<h2 id="NoSQL-분류"><a href="#NoSQL-분류" class="headerlink" title="NoSQL 분류"></a>NoSQL 분류</h2><p>NoSQL은 분류 방식에 따라 다르게 나누어진다. 이 글에서는 키에 저장된 값의 데이터 형식에 따라서 분류하겠다. <br></p>
<ul>
<li>키-값 모델 <br><blockquote>
<p>키 값 모델의 가장 큰 특징은 단순한 저장구조를 갖으며, 복잡한 조회 연산을 지원하지 않는다. 저장되는 값을 단지 의미 없는 바이너리 데이터로 처리. 고속 읽기와 쓰기에 최적화된 경우가 많다. <br><br>키-값 모델 NoSQL 예 : Redis, Riak 등 <br><br>키-값 모델의 특징을 고려해 볼때, 단일 연산에 처리할 수 있는 데이터들을 저장하는데 적합하다. 참여한 프로젝트의 경우는 자주검색되는 데이터를 Redis에 set하고, RDBMS 조회전에 Redis를 먼저 바라봄으로서 검색속도를 비약적으로 개선했다. <strong><em>결론, 하나의 서비스 요청에 단일 연산 처리로 대응할수 있는 시스템에 적합하다.</em></strong></p>
</blockquote>
</li>
</ul>
<p><br></p>
<ul>
<li>문서 모델 <br><blockquote>
<p><strong><em>문서모델 NoSQL 은 하나의 키에 구조화된 문서를 저장하고 조회한다.</em></strong>  문서모델에서 의미하는 구조화된 문서란 가장 대표적으로 JSON이 있으며, XML과 같이 구조를 갖는 문서를 말한다. 저장된 문서를 컬렉션으로 관리하고, 저장과 동시에 문서 ID에 대한 인덱스를 생성한다. 문서모델의 키는 문서에 대한 ID로 표현됨. 키-값 및 컬럼 모델에 비하여 많은 종류의 기능을 제공하며, <strong><em>RBMS와 유사한 검색조건을 포함한 쿼리를 처리할 수 있다.</em></strong> 이러한 특징 덕분에 문서모델 NoSQL은 많은 인기를 얻고 있다. 대부분의 문서 모델 NoSQL은 B트리 인덱스를 사용하여 2차 인덱스를 생성한다.  그러나 B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할때 성능이 떨어지게 된다. 이러한 이유로 B트리를 사용하는 문서 모델 NoSQL은 읽기와 쓰기 비율을 7:3 이상으로 유지할때 더 좋은 성능을 보인다. <strong><em>결국 사용하는 문서 모델 NoSQL의 특징을 파악하고 사용하자.</em></strong> <br><br>B트리의 특성 떄문에 한 번 작성되면 자주 변하지 않는 정보를 저장하고 조회하는데 적합하며, 로그저장, 타임라인 저장, 채팅로그 기록이나 조회에 적합하다. <br><br>문서 모델 NoSQL 예: 많은 인기를 얻고 있는 MongoDB <br><br>NoSQL의 개념을 빠르게 잡고 MongoDB를 학습, 프로젝트를 진행할 예정이다. 여러분 함께해요~.</p>
</blockquote>
</li>
</ul>
<p><br></p>
<ul>
<li>그 밖의 모델<blockquote>
<p>위 두가지 모델 이외에도 컬럼 모델 NoSQL, 그래프 모델 NoSQL 등이 있으나 필자의 능력을 벗어남을 판단했다. 다음 가장 중요한 파트라 생각되는 “언제 어떤 NoSQL을 사용해야 하는가?”로 넘어가겠다.</p>
</blockquote>
</li>
</ul>
<h2 id="언제-어떤-NoSQL을-사용해야-하는가"><a href="#언제-어떤-NoSQL을-사용해야-하는가" class="headerlink" title="언제 어떤 NoSQL을 사용해야 하는가?"></a>언제 어떤 NoSQL을 사용해야 하는가?</h2><p>NoSQL은 RDMS를 단순히 대체하기 위해 나온 시스템이아니다. 그렇기에 정확한 기본지식 없이 사용하면 많은 시행착오와 장애를 맞이하게 될 수 있다<br>그렇다면 NoSQL 시스템을 서비스에 적용하기 위해서는 무엇이 필요할지 정리해 볼 것이다.<br>작성자의 수준에 맞춰 이해가 어려운 부분은 제외 하였으니 더 많은 정보를 원한다면 아래 Reference를 참고하기 바란다.</p>
<p>대량의 단순 정보를 빠르게 저장하고 조회할 때, 관계형 데이터베이스가 처리하지 못하는 대량의 데이터를 입력할때 스키마가 고정되지 않은 데이터를 저장하고 조회할 떄 등이 이에 해당된다. 하지만 위와 같은 상황에서 무턱대고 아무 NoSQL을 적용한다면 큰 낭패를 보게 될 것이다. <strong><em>결국 시스템의 상황을 고려하여, 서비스 특징에 맞는 적합한 NoSQL 저장소를 택하여야 한다.</em></strong>  NoSQL의 선택에 있어 고려해야 할 사항으로는 다음과 같다.</p>
<ul>
<li>일관성 모델 : 서비스에서 저장하려는 데이터가 어느 정도의 일관성이 필요한지 확인하여야한다.</li>
<li>데이터 모델 : 저장하려는 데이터가 키-값 모델과 같은 간단한 데이터 모델로 처리가 가능한지 또는 문서 모델과 같이 중첩된 구조를 지원해야 하는지 판단해야 한다.</li>
<li>읽기 쓰기 성능 : 앞에서 말했듯이 읽기와 쓰기 비율에 따라서 적합한 NoSQL이 다르다. 빠른 응답시간이 필요하다면 인메모리 NoSQL이 적합하며, 상대적으로 읽기 비율이 높다면 문서-모델 NoSQL이 후보가 될 수 있다. (듣던 중 반가운 소리!! 필자가 개발하는 서비스의 특성상 읽기의 비율이 높다.)</li>
<li>원자성 지원 : 선택한 NoSQL의 트랜잭션 지원 여부, 단일 연산에 대한 연자성 지원 여부 등도 학인해야 한다. (이 부분은 확인 필요)</li>
</ul>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p><strong><em>장점만 갖는 시스템은 존재하지 않는다. NoSQL의 환상에 빠지지 말고, 서비스가 NoSQL 적용이 적합한지, 적합하다면 어떤 NoSQL 이 알맞는지 판단하여야 할 것이다.</em></strong></p>
<p>위 내용은 아래 Reference의 내용을 토대로 작성되었습니다. 특히, 이번 포스팅은 제가 즐겨 듣는 팟케스트 꿈과 희망의 나는프로그래머다 공식 후훤사 한빛미디어의 책 “정경석 - 이것이 Redis다” 를 주로 참고하였습니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://bcho.tistory.com/666" target="_blank" rel="external">http://bcho.tistory.com/666</a><br><a href="http://bcho.tistory.com/665" target="_blank" rel="external">http://bcho.tistory.com/665</a><br><a href="https://velopert.com/436" target="_blank" rel="external">https://velopert.com/436</a><br>책 : 정경석 - 이것이 Redis 다</p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc orderedList:0 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nosql-그리고-mongodb-입문&quot;&gt;NoSQL 그리고 MongoDB 입문&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#nosql-개념과-특징&quot;&gt;NoSQL 개념과 특징&lt;/
    
    </summary>
    
      <category term="NoSQL" scheme="https://selo77.github.io/categories/NoSQL/"/>
    
      <category term="Basic" scheme="https://selo77.github.io/categories/NoSQL/Basic/"/>
    
    
      <category term="NoSQL" scheme="https://selo77.github.io/tags/NoSQL/"/>
    
      <category term="MongoDB" scheme="https://selo77.github.io/tags/MongoDB/"/>
    
      <category term="Redis" scheme="https://selo77.github.io/tags/Redis/"/>
    
      <category term="Database" scheme="https://selo77.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Python - Python?</title>
    <link href="https://selo77.github.io/2016/06/23/Python-definition/"/>
    <id>https://selo77.github.io/2016/06/23/Python-definition/</id>
    <published>2016-06-23T11:17:28.000Z</published>
    <updated>2016-07-10T06:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc orderedList:0 -->
<ul>
<li><a href="#python-이란-사랑입니다"><strong>Python 이란? 사랑입니다.</strong></a><ul>
<li><a href="#개요">개요</a></li>
<li><a href="#특징">특징</a><ul>
<li><a href="#높은-생산성">높은 생산성</a></li>
<li><a href="#간결-그리고-아름다움">간결 그리고 아름다움</a></li>
<li><a href="#반복-가능한-객체">반복 가능한 객체</a></li>
<li><a href="#만능-언어">만능 언어</a></li>
</ul>
</li>
<li><a href="#결론">결론</a></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#related-posts">Related Posts</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1 id="Python-이란-사랑입니다"><a href="#Python-이란-사랑입니다" class="headerlink" title="Python 이란? 사랑입니다."></a><strong>Python 이란? 사랑입니다.</strong></h1><p>이 포스팅은 가로 1400px 이상의 화면에 최적화 되있습니다.</p>
<p>저는 Python 개발자입니다. 매일 같이 Python을 사용하여 로직을 구현하고, 프로그램을 작성합니다. Python은 정말 재밌습니다. 간결한 문법, 상상을 뛰어넘는 가독성!! 무엇보다 생산성에서는 제가 접한 몇개 안되는 언어들 중 최고에 속합니다. 또한 풍부한 모듈과 내장함수들은 Python과 사랑에 빠지게 만듭니다.</p>
<p>그러나 Python에 대한 열정만큼 Python을 특징을 잘 파악하지 못하고, 단순히 내장함수나 모듈을 쓰는 단계에서 그치는 것이 아닌가 라는 걱정을 하게되었고, 파이썬의 특징을 집고 넘어가자는 취지로 포스팅하게 되었습니다.</p>
<p>포스팅 주제와 관련된 필자의 수준은 다음과 같습니다. (능력 평가는 지극히 주관적임을 밝힙니다.)</p>
<pre><code>사용가능 언어
- Java7 중급
- Python3 중급
- ECMA6 중급
</code></pre><p>(하나 라도 제대로 해야할텐데 ㅠㅠ 그래서 요즘은 파이썬에 집중하려 합니다. 하지만 이놈의 호기심 때문에 함수형 언어에 기웃기웃하고 있네요.)</p>
<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>파이썬은 1989년 귀도 반 로썸의 재미로 만들어젔습니다. 리눅스 토발즈의 리눅스도 그렇고 천재들은 심심할때 대작을 만드는 듯합니다.</p>
<p><em>파이썬은 문법이 매우 쉬워서 초보자들이 처음 프로그래밍을 배울때 추천되는 언어이며, 동시에 실사용률과 생산성도 높은 강력한 언어입니다.</em></p>
<p><a href="http://www.tiobe.com/tiobe_index" target="_blank" rel="external">2016년 5월 기준 토비 프로그래밍 언어 월간 점유율</a> 을 확인해보시면 현재 5위에 랭크되있습니다.</p>
<p>범용 프로그래밍언어로서 초보자부터 전문가까지 넓은 사용자층을 보유하고 있습니다. 변수의 자료형을 선언하지 않는 <strong>동적 타이핑 언어</strong> 이며(Runtime에 자료형을 검사), <strong>인터프리터</strong> 에 의해 해석과 동시에 프로그램이 실행되는 스크립트 언어입니다.</p>
<p>파이썬은 현재 지속적인 발전과 더 많은 사용자층을 확보해가고 있습니다. 구글에서는 C++, JAVA와 함께 3대 개발 언어 중 하나로 알려져 있습니다. 최근 파이썬은 deep learning, data science 등 트렌디한 분야에서 특히 많이 사용되고있습니다. machine learning에 관심 있는 분이라면 Google이 개발한 deep learning 라이브러리인 TensorFlow를 권해드립니다. 역시 구글신!!</p>
<h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><p>파이썬은 정말 다양한 분야에서 쓰이고있습니다. 그 이유는 파이썬의 다양한 특징때문일 것입니다. 그럼 같이 파이썬에 특징에 대해 알아볼까요. Here we go~!!</p>
<ul>
<li><h3 id="높은-생산성"><a href="#높은-생산성" class="headerlink" title="높은 생산성"></a>높은 생산성</h3><p><strong>Life is short, you need python (인생은 너무 짧으니 파이썬이 필요해)</strong><br>인터프린트 언어이면서 우수한 자료형과 내부 모듈 등을 제공해 개발기간을 단축시킬 수 있습니다. 또한 수많은 오픈 서드파트 라이브러리를 사용하시면 그 속도를 배가 시킬수있습니다.<br><br>빠른 아이디어 구현이 중요한 연구소에서 각광 받고 있으며, 우리나라에서는 정부의 자바라는 큰 장벽이 존재함에도 불구하고, 스타트업에서 가장 많이 사용하는 언어 중 하나입니다. 기술트렌드에 민감한 스타트업 기업들을 위한 전문 채용 사이트 살펴본다면, Python의 인기를 실감할 수 있습니다.<br><a href="https://www.rocketpunch.com/" target="_blank" rel="external">로켓펀치 - 스타트업 백과사전</a><br><br>PS. 사실 파이썬은 우리나라를 제외한 다른 나라에서는 이미 오래전부터 주류 언어로 사용되고 있었습니다.</p>
</li>
</ul>
<ul>
<li><h3 id="간결-그리고-아름다움"><a href="#간결-그리고-아름다움" class="headerlink" title="간결 그리고 아름다움"></a>간결 그리고 아름다움</h3><p>아름다움의 정의는 개개인마다 다를 수 있습니다. 하지만 다수가 인정하는 미의 기준은 한 곳에 수렴하기 마련입니다. 파이썬의 디자인 철학은 아름다움의 수렴이라는 포커스에 맞춰져있습니다.<br><br>가장 아름다운 하나의 답이 존재한다. 앞의 명제는 파이썬의 모토이며 이와 같은 대 명제를 토대로 다음과 같은 철학을 지니게 되었습니다.<br></p>
<ul>
<li>아름다운 것이 추한 것보다 낫다.</li>
<li>명시적인 것이 암시적인 것보다 낫다.</li>
<li>간결한 것이 복잡한 것보다 낫다.</li>
<li>정교한 것이 난잡한 것보다 낫다.</li>
</ul>
<p>저는 이와 같은 디자인 철학에 백퍼센트 동의하진 않지만, 복잡하지 않으면서 명확하고, 심플한 파이썬스러움은 파이썬을 사용하기에 충분히 매력적으로 다가 왔습니다. 파이썬스러움(pythonic)한 코드를 짜기 위한 몇가지 규칙이 정의 되어있는데 PEP8 이라는 코드 스타일 규정이 존재합니다. <br><br><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">PEP 8 – Style Guide for Python Code</a><br><a href="https://spoqa.github.io/2012/08/03/about-python-coding-convention.html" target="_blank" rel="external">파이썬 코딩 컨벤션</a><br><br>이러한 아름다움과 간결한 문법 덕분에 파이썬은 배우기 쉬우며, 높은 가독성을 제공합니다. 덕분에 C, C++, JAVA 같은 언어로 개설 되던 대학 수업들이 Python으로 옮겨 가는 추세입니다. 우리나라 대학 중에는 연세대, 카이스트, 부산대, 국민대, 인천대에서 이미 프로그래밍 개론 수업을 Python으로 진행하고 있습니다.</p>
</li>
<li><h3 id="반복-가능한-객체"><a href="#반복-가능한-객체" class="headerlink" title="반복 가능한 객체"></a>반복 가능한 객체</h3><p>프로그래머에게 조건문과 반복문은 컴퓨터와 소통하는 가장 중요한 도구 중 하나에 속합니다. 파이썬에는 반복 가능한 객체(iterable)가 존재하는데, 기존의 반복문이 청동무기 였다면 철무기쯤으로 업그레이드 시켜줍니다. <br><br>이 객체는 집합, 문자열, 튜플, 딕셔너리, 그리고 함수 등 iterable한 모든 객체를 의미합니다. 이뿐만 아니라 반복 가능한 객체에는 헬퍼 메소드가 존재하여 생산성 또한 증가시킵니다. 특히 함수의 반복은 큰 장점이 됩니다. 아래 작성한 코드를 보시고 어느 로직에 응용할 수 있을지 생각해보세요~.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple</span><span class="params">(n)</span>:</span></span><br><span class="line">  x = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">yield</span> n*x</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = factorial(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># print(f.__next__()) # 10</span></span><br><span class="line"><span class="comment"># print(f.__next__()) # 20</span></span><br><span class="line"><span class="comment"># print(f.__next__()) # 30</span></span><br><span class="line"></span><br><span class="line">print(next(f)) <span class="comment"># 10</span></span><br><span class="line">print(next(f)) <span class="comment"># 20</span></span><br><span class="line">print(next(f)) <span class="comment"># 30</span></span><br></pre></td></tr></table></figure>
<p>위 코드의 프린트 값을 보면 함수가 값을 리턴했음에도 함수 내부 환경이 유지 됩니다. 자바스크립트를 공부하신 분이라면 클로져가 떠오를 수도 있겠지요. <br><br>Anyway 위 함수가 종료되기 전까지 지역변수를 유지합니다. 결국 위의 함수의 계속 호출한다면 값은 지속적으로 증가하겠지요?</p>
</li>
<li><h3 id="만능-언어"><a href="#만능-언어" class="headerlink" title="만능 언어"></a>만능 언어</h3><p>최근의 언어트렌드는 높은 생산성과 만능언어가 아닐까 생각합니다. 물론 분야마다 차이는 존재하지만 명백한 사실입니다. 인기도를 측정해볼 수 있는 척도중 하나인 Stack Over Flow의 언어 카테고리당 질문율을 살펴보면 정확한 수치도 확인할 수 있습니다.<br><a href="http://stackoverflow.com/research/developer-survey-2016" target="_blank" rel="external">2016 Stack overflow - Developer Survey Results</a><br><br>그렇다면 파이썬은 어떤면 때문에 만능언어일까요? <br><br>첫번째, 이유는 Python으로 공급되는 다양한 분야의 방대한 패키지입니다.<br>궁금하신분은 아래 사이트를 참고하세요.<br><a href="http://pypi-ranking.info/alltime" target="_blank" rel="external">PyPL Ranking</a> <br><br>두번째, 다양한 자료구조와 글루언어(다른언어와 접착성)로서의 역할 입니다.<br>이 부분을 언급하기전에 파이썬의 단점 하나를 집고 넘어가자면 속도입니다. 실행환경에서 타입을 설정하는 언어의 특성상 느릴수 밖에 없지만, 다른 동적 언어들(JavaScript, LISP …)과 비교해봐도 속도가 빠른편은 아닙니다. 하지만 다른언어들(C, JAVA 등 메인언어)과의 높은 결합성 덕분에 속도적인 이슈가 있는 부분은 C로 작성하고, 생산성이 중요한 부분은 Python으로 작성한다면 속도 이슈를 해결할 수 있습니다. 특히, Python 자체가 C로 구현되었기 때문에 C와 궁합이 잘 맞는다고 합니다.</p>
</li>
</ul>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>저에게 파이썬은 아름답습니다. 배우기 쉽고, 간결하며 높은 생산성을 갖고 있습니다. 그렇지만 파이썬 언어도 결국은 프로그래머의 하나의 도구에 불과합니다. <strong><em>단순히 프로그래밍을 할 수 있는 것과 좋은 프로그래밍을 하는 것은 하늘과 땅 차이입니다. 결국 프로그래밍의 수준은 언어가 아닌 프로그래머의 역량입니다.</em></strong> 결론적으로 프로그래밍 자체를 아름답게 하기 위해서는 언어에 상관없이 프로그래밍 자체를 공부해야 합니다. 알고리즘, 디자인패턴, 아키텍처, 테스트기법, 동시성, 자료구조 등의 필요한 지식을 유기적으로 이해할 수 있다면 어떤 언어를 사용하더라도 아름다운 프로그래밍을 할 수 있는 개발자가 될 것이라 생각합니다. <br><br>PS. 부족한 하거나 잘 못된 부분에 대한 지적은 감사히 받겠습니다. 부족한 글 끝까지 읽어주셔서 감사합니다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://wikidocs.net/book/1" target="_blank" rel="external">점프 투 파이썬 : Python의 기본을 쉽게 익히기에 좋은 사이트</a><br><a href="https://ko.wikipedia.org/wiki/파이썬" target="_blank" rel="external">파이썬 - 위키백과</a><br><a href="https://namu.wiki/w/Python" target="_blank" rel="external">파이썬 - 나무위키</a><br>rochan87@gmail.com 필자의 머릿속.</p>
<hr>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc orderedList:0 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#python-이란-사랑입니다&quot;&gt;&lt;strong&gt;Python 이란? 사랑입니다.&lt;/strong&gt;&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#개요&quot;&gt;개요&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Python" scheme="https://selo77.github.io/categories/Python/"/>
    
      <category term="Language" scheme="https://selo77.github.io/categories/Python/Language/"/>
    
    
      <category term="python" scheme="https://selo77.github.io/tags/python/"/>
    
  </entry>
  
</feed>
